// Code generated by ent, DO NOT EDIT.
// --------------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2025 The DependencyTrack Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// --------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --------------------------------------------------------------------

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"dependencytrack.io/hyades/ent/migrate"

	"dependencytrack.io/hyades/ent/apikey"
	"dependencytrack.io/hyades/ent/configproperty"
	"dependencytrack.io/hyades/ent/eventservicelog"
	"dependencytrack.io/hyades/ent/installedupgrades"
	"dependencytrack.io/hyades/ent/ldapuser"
	"dependencytrack.io/hyades/ent/manageduser"
	"dependencytrack.io/hyades/ent/mappedldapgroup"
	"dependencytrack.io/hyades/ent/mappedoidcgroup"
	"dependencytrack.io/hyades/ent/oidcgroup"
	"dependencytrack.io/hyades/ent/oidcuser"
	"dependencytrack.io/hyades/ent/permission"
	"dependencytrack.io/hyades/ent/schemaversion"
	"dependencytrack.io/hyades/ent/team"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIKey is the client for interacting with the APIKey builders.
	APIKey *APIKeyClient
	// ConfigProperty is the client for interacting with the ConfigProperty builders.
	ConfigProperty *ConfigPropertyClient
	// EventServiceLog is the client for interacting with the EventServiceLog builders.
	EventServiceLog *EventServiceLogClient
	// INSTALLEDUPGRADES is the client for interacting with the INSTALLEDUPGRADES builders.
	INSTALLEDUPGRADES *INSTALLEDUPGRADESClient
	// LDAPUser is the client for interacting with the LDAPUser builders.
	LDAPUser *LDAPUserClient
	// ManagedUser is the client for interacting with the ManagedUser builders.
	ManagedUser *ManagedUserClient
	// MappedLDAPGroup is the client for interacting with the MappedLDAPGroup builders.
	MappedLDAPGroup *MappedLDAPGroupClient
	// MappedOIDCGroup is the client for interacting with the MappedOIDCGroup builders.
	MappedOIDCGroup *MappedOIDCGroupClient
	// OIDCGroup is the client for interacting with the OIDCGroup builders.
	OIDCGroup *OIDCGroupClient
	// OIDCUser is the client for interacting with the OIDCUser builders.
	OIDCUser *OIDCUserClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// SchemaVersion is the client for interacting with the SchemaVersion builders.
	SchemaVersion *SchemaVersionClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIKey = NewAPIKeyClient(c.config)
	c.ConfigProperty = NewConfigPropertyClient(c.config)
	c.EventServiceLog = NewEventServiceLogClient(c.config)
	c.INSTALLEDUPGRADES = NewINSTALLEDUPGRADESClient(c.config)
	c.LDAPUser = NewLDAPUserClient(c.config)
	c.ManagedUser = NewManagedUserClient(c.config)
	c.MappedLDAPGroup = NewMappedLDAPGroupClient(c.config)
	c.MappedOIDCGroup = NewMappedOIDCGroupClient(c.config)
	c.OIDCGroup = NewOIDCGroupClient(c.config)
	c.OIDCUser = NewOIDCUserClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.SchemaVersion = NewSchemaVersionClient(c.config)
	c.Team = NewTeamClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		APIKey:            NewAPIKeyClient(cfg),
		ConfigProperty:    NewConfigPropertyClient(cfg),
		EventServiceLog:   NewEventServiceLogClient(cfg),
		INSTALLEDUPGRADES: NewINSTALLEDUPGRADESClient(cfg),
		LDAPUser:          NewLDAPUserClient(cfg),
		ManagedUser:       NewManagedUserClient(cfg),
		MappedLDAPGroup:   NewMappedLDAPGroupClient(cfg),
		MappedOIDCGroup:   NewMappedOIDCGroupClient(cfg),
		OIDCGroup:         NewOIDCGroupClient(cfg),
		OIDCUser:          NewOIDCUserClient(cfg),
		Permission:        NewPermissionClient(cfg),
		SchemaVersion:     NewSchemaVersionClient(cfg),
		Team:              NewTeamClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		APIKey:            NewAPIKeyClient(cfg),
		ConfigProperty:    NewConfigPropertyClient(cfg),
		EventServiceLog:   NewEventServiceLogClient(cfg),
		INSTALLEDUPGRADES: NewINSTALLEDUPGRADESClient(cfg),
		LDAPUser:          NewLDAPUserClient(cfg),
		ManagedUser:       NewManagedUserClient(cfg),
		MappedLDAPGroup:   NewMappedLDAPGroupClient(cfg),
		MappedOIDCGroup:   NewMappedOIDCGroupClient(cfg),
		OIDCGroup:         NewOIDCGroupClient(cfg),
		OIDCUser:          NewOIDCUserClient(cfg),
		Permission:        NewPermissionClient(cfg),
		SchemaVersion:     NewSchemaVersionClient(cfg),
		Team:              NewTeamClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIKey, c.ConfigProperty, c.EventServiceLog, c.INSTALLEDUPGRADES, c.LDAPUser,
		c.ManagedUser, c.MappedLDAPGroup, c.MappedOIDCGroup, c.OIDCGroup, c.OIDCUser,
		c.Permission, c.SchemaVersion, c.Team,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIKey, c.ConfigProperty, c.EventServiceLog, c.INSTALLEDUPGRADES, c.LDAPUser,
		c.ManagedUser, c.MappedLDAPGroup, c.MappedOIDCGroup, c.OIDCGroup, c.OIDCUser,
		c.Permission, c.SchemaVersion, c.Team,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIKeyMutation:
		return c.APIKey.mutate(ctx, m)
	case *ConfigPropertyMutation:
		return c.ConfigProperty.mutate(ctx, m)
	case *EventServiceLogMutation:
		return c.EventServiceLog.mutate(ctx, m)
	case *INSTALLEDUPGRADESMutation:
		return c.INSTALLEDUPGRADES.mutate(ctx, m)
	case *LDAPUserMutation:
		return c.LDAPUser.mutate(ctx, m)
	case *ManagedUserMutation:
		return c.ManagedUser.mutate(ctx, m)
	case *MappedLDAPGroupMutation:
		return c.MappedLDAPGroup.mutate(ctx, m)
	case *MappedOIDCGroupMutation:
		return c.MappedOIDCGroup.mutate(ctx, m)
	case *OIDCGroupMutation:
		return c.OIDCGroup.mutate(ctx, m)
	case *OIDCUserMutation:
		return c.OIDCUser.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *SchemaVersionMutation:
		return c.SchemaVersion.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIKeyClient is a client for the APIKey schema.
type APIKeyClient struct {
	config
}

// NewAPIKeyClient returns a client for the APIKey from the given config.
func NewAPIKeyClient(c config) *APIKeyClient {
	return &APIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikey.Hooks(f(g(h())))`.
func (c *APIKeyClient) Use(hooks ...Hook) {
	c.hooks.APIKey = append(c.hooks.APIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikey.Intercept(f(g(h())))`.
func (c *APIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIKey = append(c.inters.APIKey, interceptors...)
}

// Create returns a builder for creating a APIKey entity.
func (c *APIKeyClient) Create() *APIKeyCreate {
	mutation := newAPIKeyMutation(c.config, OpCreate)
	return &APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIKey entities.
func (c *APIKeyClient) CreateBulk(builders ...*APIKeyCreate) *APIKeyCreateBulk {
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIKeyClient) MapCreateBulk(slice any, setFunc func(*APIKeyCreate, int)) *APIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIKeyCreateBulk{err: fmt.Errorf("calling to APIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIKey.
func (c *APIKeyClient) Update() *APIKeyUpdate {
	mutation := newAPIKeyMutation(c.config, OpUpdate)
	return &APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIKeyClient) UpdateOne(ak *APIKey) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKey(ak))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIKeyClient) UpdateOneID(id int) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKeyID(id))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIKey.
func (c *APIKeyClient) Delete() *APIKeyDelete {
	mutation := newAPIKeyMutation(c.config, OpDelete)
	return &APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIKeyClient) DeleteOne(ak *APIKey) *APIKeyDeleteOne {
	return c.DeleteOneID(ak.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIKeyClient) DeleteOneID(id int) *APIKeyDeleteOne {
	builder := c.Delete().Where(apikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIKeyDeleteOne{builder}
}

// Query returns a query builder for APIKey.
func (c *APIKeyClient) Query() *APIKeyQuery {
	return &APIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a APIKey entity by its id.
func (c *APIKeyClient) Get(ctx context.Context, id int) (*APIKey, error) {
	return c.Query().Where(apikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIKeyClient) GetX(ctx context.Context, id int) *APIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeams queries the teams edge of a APIKey.
func (c *APIKeyClient) QueryTeams(ak *APIKey) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ak.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, apikey.TeamsTable, apikey.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ak.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIKeyClient) Hooks() []Hook {
	return c.hooks.APIKey
}

// Interceptors returns the client interceptors.
func (c *APIKeyClient) Interceptors() []Interceptor {
	return c.inters.APIKey
}

func (c *APIKeyClient) mutate(ctx context.Context, m *APIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIKey mutation op: %q", m.Op())
	}
}

// ConfigPropertyClient is a client for the ConfigProperty schema.
type ConfigPropertyClient struct {
	config
}

// NewConfigPropertyClient returns a client for the ConfigProperty from the given config.
func NewConfigPropertyClient(c config) *ConfigPropertyClient {
	return &ConfigPropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configproperty.Hooks(f(g(h())))`.
func (c *ConfigPropertyClient) Use(hooks ...Hook) {
	c.hooks.ConfigProperty = append(c.hooks.ConfigProperty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `configproperty.Intercept(f(g(h())))`.
func (c *ConfigPropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConfigProperty = append(c.inters.ConfigProperty, interceptors...)
}

// Create returns a builder for creating a ConfigProperty entity.
func (c *ConfigPropertyClient) Create() *ConfigPropertyCreate {
	mutation := newConfigPropertyMutation(c.config, OpCreate)
	return &ConfigPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConfigProperty entities.
func (c *ConfigPropertyClient) CreateBulk(builders ...*ConfigPropertyCreate) *ConfigPropertyCreateBulk {
	return &ConfigPropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConfigPropertyClient) MapCreateBulk(slice any, setFunc func(*ConfigPropertyCreate, int)) *ConfigPropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConfigPropertyCreateBulk{err: fmt.Errorf("calling to ConfigPropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConfigPropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConfigPropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConfigProperty.
func (c *ConfigPropertyClient) Update() *ConfigPropertyUpdate {
	mutation := newConfigPropertyMutation(c.config, OpUpdate)
	return &ConfigPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigPropertyClient) UpdateOne(cp *ConfigProperty) *ConfigPropertyUpdateOne {
	mutation := newConfigPropertyMutation(c.config, OpUpdateOne, withConfigProperty(cp))
	return &ConfigPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigPropertyClient) UpdateOneID(id int) *ConfigPropertyUpdateOne {
	mutation := newConfigPropertyMutation(c.config, OpUpdateOne, withConfigPropertyID(id))
	return &ConfigPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConfigProperty.
func (c *ConfigPropertyClient) Delete() *ConfigPropertyDelete {
	mutation := newConfigPropertyMutation(c.config, OpDelete)
	return &ConfigPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigPropertyClient) DeleteOne(cp *ConfigProperty) *ConfigPropertyDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConfigPropertyClient) DeleteOneID(id int) *ConfigPropertyDeleteOne {
	builder := c.Delete().Where(configproperty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigPropertyDeleteOne{builder}
}

// Query returns a query builder for ConfigProperty.
func (c *ConfigPropertyClient) Query() *ConfigPropertyQuery {
	return &ConfigPropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConfigProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a ConfigProperty entity by its id.
func (c *ConfigPropertyClient) Get(ctx context.Context, id int) (*ConfigProperty, error) {
	return c.Query().Where(configproperty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigPropertyClient) GetX(ctx context.Context, id int) *ConfigProperty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigPropertyClient) Hooks() []Hook {
	return c.hooks.ConfigProperty
}

// Interceptors returns the client interceptors.
func (c *ConfigPropertyClient) Interceptors() []Interceptor {
	return c.inters.ConfigProperty
}

func (c *ConfigPropertyClient) mutate(ctx context.Context, m *ConfigPropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConfigPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConfigPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConfigPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConfigPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConfigProperty mutation op: %q", m.Op())
	}
}

// EventServiceLogClient is a client for the EventServiceLog schema.
type EventServiceLogClient struct {
	config
}

// NewEventServiceLogClient returns a client for the EventServiceLog from the given config.
func NewEventServiceLogClient(c config) *EventServiceLogClient {
	return &EventServiceLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventservicelog.Hooks(f(g(h())))`.
func (c *EventServiceLogClient) Use(hooks ...Hook) {
	c.hooks.EventServiceLog = append(c.hooks.EventServiceLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventservicelog.Intercept(f(g(h())))`.
func (c *EventServiceLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventServiceLog = append(c.inters.EventServiceLog, interceptors...)
}

// Create returns a builder for creating a EventServiceLog entity.
func (c *EventServiceLogClient) Create() *EventServiceLogCreate {
	mutation := newEventServiceLogMutation(c.config, OpCreate)
	return &EventServiceLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventServiceLog entities.
func (c *EventServiceLogClient) CreateBulk(builders ...*EventServiceLogCreate) *EventServiceLogCreateBulk {
	return &EventServiceLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventServiceLogClient) MapCreateBulk(slice any, setFunc func(*EventServiceLogCreate, int)) *EventServiceLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventServiceLogCreateBulk{err: fmt.Errorf("calling to EventServiceLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventServiceLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventServiceLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventServiceLog.
func (c *EventServiceLogClient) Update() *EventServiceLogUpdate {
	mutation := newEventServiceLogMutation(c.config, OpUpdate)
	return &EventServiceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventServiceLogClient) UpdateOne(esl *EventServiceLog) *EventServiceLogUpdateOne {
	mutation := newEventServiceLogMutation(c.config, OpUpdateOne, withEventServiceLog(esl))
	return &EventServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventServiceLogClient) UpdateOneID(id int) *EventServiceLogUpdateOne {
	mutation := newEventServiceLogMutation(c.config, OpUpdateOne, withEventServiceLogID(id))
	return &EventServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventServiceLog.
func (c *EventServiceLogClient) Delete() *EventServiceLogDelete {
	mutation := newEventServiceLogMutation(c.config, OpDelete)
	return &EventServiceLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventServiceLogClient) DeleteOne(esl *EventServiceLog) *EventServiceLogDeleteOne {
	return c.DeleteOneID(esl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventServiceLogClient) DeleteOneID(id int) *EventServiceLogDeleteOne {
	builder := c.Delete().Where(eventservicelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventServiceLogDeleteOne{builder}
}

// Query returns a query builder for EventServiceLog.
func (c *EventServiceLogClient) Query() *EventServiceLogQuery {
	return &EventServiceLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventServiceLog},
		inters: c.Interceptors(),
	}
}

// Get returns a EventServiceLog entity by its id.
func (c *EventServiceLogClient) Get(ctx context.Context, id int) (*EventServiceLog, error) {
	return c.Query().Where(eventservicelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventServiceLogClient) GetX(ctx context.Context, id int) *EventServiceLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventServiceLogClient) Hooks() []Hook {
	return c.hooks.EventServiceLog
}

// Interceptors returns the client interceptors.
func (c *EventServiceLogClient) Interceptors() []Interceptor {
	return c.inters.EventServiceLog
}

func (c *EventServiceLogClient) mutate(ctx context.Context, m *EventServiceLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventServiceLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventServiceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventServiceLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventServiceLog mutation op: %q", m.Op())
	}
}

// INSTALLEDUPGRADESClient is a client for the INSTALLEDUPGRADES schema.
type INSTALLEDUPGRADESClient struct {
	config
}

// NewINSTALLEDUPGRADESClient returns a client for the INSTALLEDUPGRADES from the given config.
func NewINSTALLEDUPGRADESClient(c config) *INSTALLEDUPGRADESClient {
	return &INSTALLEDUPGRADESClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `installedupgrades.Hooks(f(g(h())))`.
func (c *INSTALLEDUPGRADESClient) Use(hooks ...Hook) {
	c.hooks.INSTALLEDUPGRADES = append(c.hooks.INSTALLEDUPGRADES, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `installedupgrades.Intercept(f(g(h())))`.
func (c *INSTALLEDUPGRADESClient) Intercept(interceptors ...Interceptor) {
	c.inters.INSTALLEDUPGRADES = append(c.inters.INSTALLEDUPGRADES, interceptors...)
}

// Create returns a builder for creating a INSTALLEDUPGRADES entity.
func (c *INSTALLEDUPGRADESClient) Create() *INSTALLEDUPGRADESCreate {
	mutation := newINSTALLEDUPGRADESMutation(c.config, OpCreate)
	return &INSTALLEDUPGRADESCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of INSTALLEDUPGRADES entities.
func (c *INSTALLEDUPGRADESClient) CreateBulk(builders ...*INSTALLEDUPGRADESCreate) *INSTALLEDUPGRADESCreateBulk {
	return &INSTALLEDUPGRADESCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *INSTALLEDUPGRADESClient) MapCreateBulk(slice any, setFunc func(*INSTALLEDUPGRADESCreate, int)) *INSTALLEDUPGRADESCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &INSTALLEDUPGRADESCreateBulk{err: fmt.Errorf("calling to INSTALLEDUPGRADESClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*INSTALLEDUPGRADESCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &INSTALLEDUPGRADESCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for INSTALLEDUPGRADES.
func (c *INSTALLEDUPGRADESClient) Update() *INSTALLEDUPGRADESUpdate {
	mutation := newINSTALLEDUPGRADESMutation(c.config, OpUpdate)
	return &INSTALLEDUPGRADESUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *INSTALLEDUPGRADESClient) UpdateOne(i *INSTALLEDUPGRADES) *INSTALLEDUPGRADESUpdateOne {
	mutation := newINSTALLEDUPGRADESMutation(c.config, OpUpdateOne, withINSTALLEDUPGRADES(i))
	return &INSTALLEDUPGRADESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *INSTALLEDUPGRADESClient) UpdateOneID(id int) *INSTALLEDUPGRADESUpdateOne {
	mutation := newINSTALLEDUPGRADESMutation(c.config, OpUpdateOne, withINSTALLEDUPGRADESID(id))
	return &INSTALLEDUPGRADESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for INSTALLEDUPGRADES.
func (c *INSTALLEDUPGRADESClient) Delete() *INSTALLEDUPGRADESDelete {
	mutation := newINSTALLEDUPGRADESMutation(c.config, OpDelete)
	return &INSTALLEDUPGRADESDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *INSTALLEDUPGRADESClient) DeleteOne(i *INSTALLEDUPGRADES) *INSTALLEDUPGRADESDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *INSTALLEDUPGRADESClient) DeleteOneID(id int) *INSTALLEDUPGRADESDeleteOne {
	builder := c.Delete().Where(installedupgrades.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &INSTALLEDUPGRADESDeleteOne{builder}
}

// Query returns a query builder for INSTALLEDUPGRADES.
func (c *INSTALLEDUPGRADESClient) Query() *INSTALLEDUPGRADESQuery {
	return &INSTALLEDUPGRADESQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeINSTALLEDUPGRADES},
		inters: c.Interceptors(),
	}
}

// Get returns a INSTALLEDUPGRADES entity by its id.
func (c *INSTALLEDUPGRADESClient) Get(ctx context.Context, id int) (*INSTALLEDUPGRADES, error) {
	return c.Query().Where(installedupgrades.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *INSTALLEDUPGRADESClient) GetX(ctx context.Context, id int) *INSTALLEDUPGRADES {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *INSTALLEDUPGRADESClient) Hooks() []Hook {
	return c.hooks.INSTALLEDUPGRADES
}

// Interceptors returns the client interceptors.
func (c *INSTALLEDUPGRADESClient) Interceptors() []Interceptor {
	return c.inters.INSTALLEDUPGRADES
}

func (c *INSTALLEDUPGRADESClient) mutate(ctx context.Context, m *INSTALLEDUPGRADESMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&INSTALLEDUPGRADESCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&INSTALLEDUPGRADESUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&INSTALLEDUPGRADESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&INSTALLEDUPGRADESDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown INSTALLEDUPGRADES mutation op: %q", m.Op())
	}
}

// LDAPUserClient is a client for the LDAPUser schema.
type LDAPUserClient struct {
	config
}

// NewLDAPUserClient returns a client for the LDAPUser from the given config.
func NewLDAPUserClient(c config) *LDAPUserClient {
	return &LDAPUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ldapuser.Hooks(f(g(h())))`.
func (c *LDAPUserClient) Use(hooks ...Hook) {
	c.hooks.LDAPUser = append(c.hooks.LDAPUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ldapuser.Intercept(f(g(h())))`.
func (c *LDAPUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.LDAPUser = append(c.inters.LDAPUser, interceptors...)
}

// Create returns a builder for creating a LDAPUser entity.
func (c *LDAPUserClient) Create() *LDAPUserCreate {
	mutation := newLDAPUserMutation(c.config, OpCreate)
	return &LDAPUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LDAPUser entities.
func (c *LDAPUserClient) CreateBulk(builders ...*LDAPUserCreate) *LDAPUserCreateBulk {
	return &LDAPUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LDAPUserClient) MapCreateBulk(slice any, setFunc func(*LDAPUserCreate, int)) *LDAPUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LDAPUserCreateBulk{err: fmt.Errorf("calling to LDAPUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LDAPUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LDAPUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LDAPUser.
func (c *LDAPUserClient) Update() *LDAPUserUpdate {
	mutation := newLDAPUserMutation(c.config, OpUpdate)
	return &LDAPUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LDAPUserClient) UpdateOne(lu *LDAPUser) *LDAPUserUpdateOne {
	mutation := newLDAPUserMutation(c.config, OpUpdateOne, withLDAPUser(lu))
	return &LDAPUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LDAPUserClient) UpdateOneID(id int) *LDAPUserUpdateOne {
	mutation := newLDAPUserMutation(c.config, OpUpdateOne, withLDAPUserID(id))
	return &LDAPUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LDAPUser.
func (c *LDAPUserClient) Delete() *LDAPUserDelete {
	mutation := newLDAPUserMutation(c.config, OpDelete)
	return &LDAPUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LDAPUserClient) DeleteOne(lu *LDAPUser) *LDAPUserDeleteOne {
	return c.DeleteOneID(lu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LDAPUserClient) DeleteOneID(id int) *LDAPUserDeleteOne {
	builder := c.Delete().Where(ldapuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LDAPUserDeleteOne{builder}
}

// Query returns a query builder for LDAPUser.
func (c *LDAPUserClient) Query() *LDAPUserQuery {
	return &LDAPUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLDAPUser},
		inters: c.Interceptors(),
	}
}

// Get returns a LDAPUser entity by its id.
func (c *LDAPUserClient) Get(ctx context.Context, id int) (*LDAPUser, error) {
	return c.Query().Where(ldapuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LDAPUserClient) GetX(ctx context.Context, id int) *LDAPUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a LDAPUser.
func (c *LDAPUserClient) QueryPermissions(lu *LDAPUser) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ldapuser.Table, ldapuser.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, ldapuser.PermissionsTable, ldapuser.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(lu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a LDAPUser.
func (c *LDAPUserClient) QueryTeams(lu *LDAPUser) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ldapuser.Table, ldapuser.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, ldapuser.TeamsTable, ldapuser.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(lu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LDAPUserClient) Hooks() []Hook {
	return c.hooks.LDAPUser
}

// Interceptors returns the client interceptors.
func (c *LDAPUserClient) Interceptors() []Interceptor {
	return c.inters.LDAPUser
}

func (c *LDAPUserClient) mutate(ctx context.Context, m *LDAPUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LDAPUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LDAPUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LDAPUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LDAPUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LDAPUser mutation op: %q", m.Op())
	}
}

// ManagedUserClient is a client for the ManagedUser schema.
type ManagedUserClient struct {
	config
}

// NewManagedUserClient returns a client for the ManagedUser from the given config.
func NewManagedUserClient(c config) *ManagedUserClient {
	return &ManagedUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `manageduser.Hooks(f(g(h())))`.
func (c *ManagedUserClient) Use(hooks ...Hook) {
	c.hooks.ManagedUser = append(c.hooks.ManagedUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `manageduser.Intercept(f(g(h())))`.
func (c *ManagedUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.ManagedUser = append(c.inters.ManagedUser, interceptors...)
}

// Create returns a builder for creating a ManagedUser entity.
func (c *ManagedUserClient) Create() *ManagedUserCreate {
	mutation := newManagedUserMutation(c.config, OpCreate)
	return &ManagedUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ManagedUser entities.
func (c *ManagedUserClient) CreateBulk(builders ...*ManagedUserCreate) *ManagedUserCreateBulk {
	return &ManagedUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ManagedUserClient) MapCreateBulk(slice any, setFunc func(*ManagedUserCreate, int)) *ManagedUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ManagedUserCreateBulk{err: fmt.Errorf("calling to ManagedUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ManagedUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ManagedUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ManagedUser.
func (c *ManagedUserClient) Update() *ManagedUserUpdate {
	mutation := newManagedUserMutation(c.config, OpUpdate)
	return &ManagedUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ManagedUserClient) UpdateOne(mu *ManagedUser) *ManagedUserUpdateOne {
	mutation := newManagedUserMutation(c.config, OpUpdateOne, withManagedUser(mu))
	return &ManagedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ManagedUserClient) UpdateOneID(id int) *ManagedUserUpdateOne {
	mutation := newManagedUserMutation(c.config, OpUpdateOne, withManagedUserID(id))
	return &ManagedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ManagedUser.
func (c *ManagedUserClient) Delete() *ManagedUserDelete {
	mutation := newManagedUserMutation(c.config, OpDelete)
	return &ManagedUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ManagedUserClient) DeleteOne(mu *ManagedUser) *ManagedUserDeleteOne {
	return c.DeleteOneID(mu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ManagedUserClient) DeleteOneID(id int) *ManagedUserDeleteOne {
	builder := c.Delete().Where(manageduser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ManagedUserDeleteOne{builder}
}

// Query returns a query builder for ManagedUser.
func (c *ManagedUserClient) Query() *ManagedUserQuery {
	return &ManagedUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeManagedUser},
		inters: c.Interceptors(),
	}
}

// Get returns a ManagedUser entity by its id.
func (c *ManagedUserClient) Get(ctx context.Context, id int) (*ManagedUser, error) {
	return c.Query().Where(manageduser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ManagedUserClient) GetX(ctx context.Context, id int) *ManagedUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a ManagedUser.
func (c *ManagedUserClient) QueryPermissions(mu *ManagedUser) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(manageduser.Table, manageduser.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, manageduser.PermissionsTable, manageduser.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(mu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a ManagedUser.
func (c *ManagedUserClient) QueryTeams(mu *ManagedUser) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(manageduser.Table, manageduser.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, manageduser.TeamsTable, manageduser.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(mu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ManagedUserClient) Hooks() []Hook {
	return c.hooks.ManagedUser
}

// Interceptors returns the client interceptors.
func (c *ManagedUserClient) Interceptors() []Interceptor {
	return c.inters.ManagedUser
}

func (c *ManagedUserClient) mutate(ctx context.Context, m *ManagedUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ManagedUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ManagedUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ManagedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ManagedUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ManagedUser mutation op: %q", m.Op())
	}
}

// MappedLDAPGroupClient is a client for the MappedLDAPGroup schema.
type MappedLDAPGroupClient struct {
	config
}

// NewMappedLDAPGroupClient returns a client for the MappedLDAPGroup from the given config.
func NewMappedLDAPGroupClient(c config) *MappedLDAPGroupClient {
	return &MappedLDAPGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappedldapgroup.Hooks(f(g(h())))`.
func (c *MappedLDAPGroupClient) Use(hooks ...Hook) {
	c.hooks.MappedLDAPGroup = append(c.hooks.MappedLDAPGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappedldapgroup.Intercept(f(g(h())))`.
func (c *MappedLDAPGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappedLDAPGroup = append(c.inters.MappedLDAPGroup, interceptors...)
}

// Create returns a builder for creating a MappedLDAPGroup entity.
func (c *MappedLDAPGroupClient) Create() *MappedLDAPGroupCreate {
	mutation := newMappedLDAPGroupMutation(c.config, OpCreate)
	return &MappedLDAPGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappedLDAPGroup entities.
func (c *MappedLDAPGroupClient) CreateBulk(builders ...*MappedLDAPGroupCreate) *MappedLDAPGroupCreateBulk {
	return &MappedLDAPGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappedLDAPGroupClient) MapCreateBulk(slice any, setFunc func(*MappedLDAPGroupCreate, int)) *MappedLDAPGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappedLDAPGroupCreateBulk{err: fmt.Errorf("calling to MappedLDAPGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappedLDAPGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappedLDAPGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappedLDAPGroup.
func (c *MappedLDAPGroupClient) Update() *MappedLDAPGroupUpdate {
	mutation := newMappedLDAPGroupMutation(c.config, OpUpdate)
	return &MappedLDAPGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappedLDAPGroupClient) UpdateOne(mlg *MappedLDAPGroup) *MappedLDAPGroupUpdateOne {
	mutation := newMappedLDAPGroupMutation(c.config, OpUpdateOne, withMappedLDAPGroup(mlg))
	return &MappedLDAPGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappedLDAPGroupClient) UpdateOneID(id int) *MappedLDAPGroupUpdateOne {
	mutation := newMappedLDAPGroupMutation(c.config, OpUpdateOne, withMappedLDAPGroupID(id))
	return &MappedLDAPGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappedLDAPGroup.
func (c *MappedLDAPGroupClient) Delete() *MappedLDAPGroupDelete {
	mutation := newMappedLDAPGroupMutation(c.config, OpDelete)
	return &MappedLDAPGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappedLDAPGroupClient) DeleteOne(mlg *MappedLDAPGroup) *MappedLDAPGroupDeleteOne {
	return c.DeleteOneID(mlg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappedLDAPGroupClient) DeleteOneID(id int) *MappedLDAPGroupDeleteOne {
	builder := c.Delete().Where(mappedldapgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappedLDAPGroupDeleteOne{builder}
}

// Query returns a query builder for MappedLDAPGroup.
func (c *MappedLDAPGroupClient) Query() *MappedLDAPGroupQuery {
	return &MappedLDAPGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappedLDAPGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a MappedLDAPGroup entity by its id.
func (c *MappedLDAPGroupClient) Get(ctx context.Context, id int) (*MappedLDAPGroup, error) {
	return c.Query().Where(mappedldapgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappedLDAPGroupClient) GetX(ctx context.Context, id int) *MappedLDAPGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a MappedLDAPGroup.
func (c *MappedLDAPGroupClient) QueryTeam(mlg *MappedLDAPGroup) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedldapgroup.Table, mappedldapgroup.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mappedldapgroup.TeamTable, mappedldapgroup.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(mlg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MappedLDAPGroupClient) Hooks() []Hook {
	return c.hooks.MappedLDAPGroup
}

// Interceptors returns the client interceptors.
func (c *MappedLDAPGroupClient) Interceptors() []Interceptor {
	return c.inters.MappedLDAPGroup
}

func (c *MappedLDAPGroupClient) mutate(ctx context.Context, m *MappedLDAPGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappedLDAPGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappedLDAPGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappedLDAPGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappedLDAPGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MappedLDAPGroup mutation op: %q", m.Op())
	}
}

// MappedOIDCGroupClient is a client for the MappedOIDCGroup schema.
type MappedOIDCGroupClient struct {
	config
}

// NewMappedOIDCGroupClient returns a client for the MappedOIDCGroup from the given config.
func NewMappedOIDCGroupClient(c config) *MappedOIDCGroupClient {
	return &MappedOIDCGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappedoidcgroup.Hooks(f(g(h())))`.
func (c *MappedOIDCGroupClient) Use(hooks ...Hook) {
	c.hooks.MappedOIDCGroup = append(c.hooks.MappedOIDCGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappedoidcgroup.Intercept(f(g(h())))`.
func (c *MappedOIDCGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappedOIDCGroup = append(c.inters.MappedOIDCGroup, interceptors...)
}

// Create returns a builder for creating a MappedOIDCGroup entity.
func (c *MappedOIDCGroupClient) Create() *MappedOIDCGroupCreate {
	mutation := newMappedOIDCGroupMutation(c.config, OpCreate)
	return &MappedOIDCGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappedOIDCGroup entities.
func (c *MappedOIDCGroupClient) CreateBulk(builders ...*MappedOIDCGroupCreate) *MappedOIDCGroupCreateBulk {
	return &MappedOIDCGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappedOIDCGroupClient) MapCreateBulk(slice any, setFunc func(*MappedOIDCGroupCreate, int)) *MappedOIDCGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappedOIDCGroupCreateBulk{err: fmt.Errorf("calling to MappedOIDCGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappedOIDCGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappedOIDCGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappedOIDCGroup.
func (c *MappedOIDCGroupClient) Update() *MappedOIDCGroupUpdate {
	mutation := newMappedOIDCGroupMutation(c.config, OpUpdate)
	return &MappedOIDCGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappedOIDCGroupClient) UpdateOne(mog *MappedOIDCGroup) *MappedOIDCGroupUpdateOne {
	mutation := newMappedOIDCGroupMutation(c.config, OpUpdateOne, withMappedOIDCGroup(mog))
	return &MappedOIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappedOIDCGroupClient) UpdateOneID(id int) *MappedOIDCGroupUpdateOne {
	mutation := newMappedOIDCGroupMutation(c.config, OpUpdateOne, withMappedOIDCGroupID(id))
	return &MappedOIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappedOIDCGroup.
func (c *MappedOIDCGroupClient) Delete() *MappedOIDCGroupDelete {
	mutation := newMappedOIDCGroupMutation(c.config, OpDelete)
	return &MappedOIDCGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappedOIDCGroupClient) DeleteOne(mog *MappedOIDCGroup) *MappedOIDCGroupDeleteOne {
	return c.DeleteOneID(mog.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappedOIDCGroupClient) DeleteOneID(id int) *MappedOIDCGroupDeleteOne {
	builder := c.Delete().Where(mappedoidcgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappedOIDCGroupDeleteOne{builder}
}

// Query returns a query builder for MappedOIDCGroup.
func (c *MappedOIDCGroupClient) Query() *MappedOIDCGroupQuery {
	return &MappedOIDCGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappedOIDCGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a MappedOIDCGroup entity by its id.
func (c *MappedOIDCGroupClient) Get(ctx context.Context, id int) (*MappedOIDCGroup, error) {
	return c.Query().Where(mappedoidcgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappedOIDCGroupClient) GetX(ctx context.Context, id int) *MappedOIDCGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOidcGroup queries the oidc_group edge of a MappedOIDCGroup.
func (c *MappedOIDCGroupClient) QueryOidcGroup(mog *MappedOIDCGroup) *OIDCGroupQuery {
	query := (&OIDCGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mog.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedoidcgroup.Table, mappedoidcgroup.FieldID, id),
			sqlgraph.To(oidcgroup.Table, oidcgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mappedoidcgroup.OidcGroupTable, mappedoidcgroup.OidcGroupColumn),
		)
		fromV = sqlgraph.Neighbors(mog.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a MappedOIDCGroup.
func (c *MappedOIDCGroupClient) QueryTeam(mog *MappedOIDCGroup) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mog.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedoidcgroup.Table, mappedoidcgroup.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mappedoidcgroup.TeamTable, mappedoidcgroup.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(mog.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MappedOIDCGroupClient) Hooks() []Hook {
	return c.hooks.MappedOIDCGroup
}

// Interceptors returns the client interceptors.
func (c *MappedOIDCGroupClient) Interceptors() []Interceptor {
	return c.inters.MappedOIDCGroup
}

func (c *MappedOIDCGroupClient) mutate(ctx context.Context, m *MappedOIDCGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappedOIDCGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappedOIDCGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappedOIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappedOIDCGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MappedOIDCGroup mutation op: %q", m.Op())
	}
}

// OIDCGroupClient is a client for the OIDCGroup schema.
type OIDCGroupClient struct {
	config
}

// NewOIDCGroupClient returns a client for the OIDCGroup from the given config.
func NewOIDCGroupClient(c config) *OIDCGroupClient {
	return &OIDCGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oidcgroup.Hooks(f(g(h())))`.
func (c *OIDCGroupClient) Use(hooks ...Hook) {
	c.hooks.OIDCGroup = append(c.hooks.OIDCGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oidcgroup.Intercept(f(g(h())))`.
func (c *OIDCGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.OIDCGroup = append(c.inters.OIDCGroup, interceptors...)
}

// Create returns a builder for creating a OIDCGroup entity.
func (c *OIDCGroupClient) Create() *OIDCGroupCreate {
	mutation := newOIDCGroupMutation(c.config, OpCreate)
	return &OIDCGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OIDCGroup entities.
func (c *OIDCGroupClient) CreateBulk(builders ...*OIDCGroupCreate) *OIDCGroupCreateBulk {
	return &OIDCGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OIDCGroupClient) MapCreateBulk(slice any, setFunc func(*OIDCGroupCreate, int)) *OIDCGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OIDCGroupCreateBulk{err: fmt.Errorf("calling to OIDCGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OIDCGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OIDCGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OIDCGroup.
func (c *OIDCGroupClient) Update() *OIDCGroupUpdate {
	mutation := newOIDCGroupMutation(c.config, OpUpdate)
	return &OIDCGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OIDCGroupClient) UpdateOne(og *OIDCGroup) *OIDCGroupUpdateOne {
	mutation := newOIDCGroupMutation(c.config, OpUpdateOne, withOIDCGroup(og))
	return &OIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OIDCGroupClient) UpdateOneID(id int) *OIDCGroupUpdateOne {
	mutation := newOIDCGroupMutation(c.config, OpUpdateOne, withOIDCGroupID(id))
	return &OIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OIDCGroup.
func (c *OIDCGroupClient) Delete() *OIDCGroupDelete {
	mutation := newOIDCGroupMutation(c.config, OpDelete)
	return &OIDCGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OIDCGroupClient) DeleteOne(og *OIDCGroup) *OIDCGroupDeleteOne {
	return c.DeleteOneID(og.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OIDCGroupClient) DeleteOneID(id int) *OIDCGroupDeleteOne {
	builder := c.Delete().Where(oidcgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OIDCGroupDeleteOne{builder}
}

// Query returns a query builder for OIDCGroup.
func (c *OIDCGroupClient) Query() *OIDCGroupQuery {
	return &OIDCGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOIDCGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a OIDCGroup entity by its id.
func (c *OIDCGroupClient) Get(ctx context.Context, id int) (*OIDCGroup, error) {
	return c.Query().Where(oidcgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OIDCGroupClient) GetX(ctx context.Context, id int) *OIDCGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMappedOidcGroups queries the mapped_oidc_groups edge of a OIDCGroup.
func (c *OIDCGroupClient) QueryMappedOidcGroups(og *OIDCGroup) *MappedOIDCGroupQuery {
	query := (&MappedOIDCGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := og.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oidcgroup.Table, oidcgroup.FieldID, id),
			sqlgraph.To(mappedoidcgroup.Table, mappedoidcgroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oidcgroup.MappedOidcGroupsTable, oidcgroup.MappedOidcGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(og.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a OIDCGroup.
func (c *OIDCGroupClient) QueryTeam(og *OIDCGroup) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := og.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oidcgroup.Table, oidcgroup.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, oidcgroup.TeamTable, oidcgroup.TeamPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(og.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OIDCGroupClient) Hooks() []Hook {
	return c.hooks.OIDCGroup
}

// Interceptors returns the client interceptors.
func (c *OIDCGroupClient) Interceptors() []Interceptor {
	return c.inters.OIDCGroup
}

func (c *OIDCGroupClient) mutate(ctx context.Context, m *OIDCGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OIDCGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OIDCGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OIDCGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OIDCGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OIDCGroup mutation op: %q", m.Op())
	}
}

// OIDCUserClient is a client for the OIDCUser schema.
type OIDCUserClient struct {
	config
}

// NewOIDCUserClient returns a client for the OIDCUser from the given config.
func NewOIDCUserClient(c config) *OIDCUserClient {
	return &OIDCUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oidcuser.Hooks(f(g(h())))`.
func (c *OIDCUserClient) Use(hooks ...Hook) {
	c.hooks.OIDCUser = append(c.hooks.OIDCUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oidcuser.Intercept(f(g(h())))`.
func (c *OIDCUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.OIDCUser = append(c.inters.OIDCUser, interceptors...)
}

// Create returns a builder for creating a OIDCUser entity.
func (c *OIDCUserClient) Create() *OIDCUserCreate {
	mutation := newOIDCUserMutation(c.config, OpCreate)
	return &OIDCUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OIDCUser entities.
func (c *OIDCUserClient) CreateBulk(builders ...*OIDCUserCreate) *OIDCUserCreateBulk {
	return &OIDCUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OIDCUserClient) MapCreateBulk(slice any, setFunc func(*OIDCUserCreate, int)) *OIDCUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OIDCUserCreateBulk{err: fmt.Errorf("calling to OIDCUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OIDCUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OIDCUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OIDCUser.
func (c *OIDCUserClient) Update() *OIDCUserUpdate {
	mutation := newOIDCUserMutation(c.config, OpUpdate)
	return &OIDCUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OIDCUserClient) UpdateOne(ou *OIDCUser) *OIDCUserUpdateOne {
	mutation := newOIDCUserMutation(c.config, OpUpdateOne, withOIDCUser(ou))
	return &OIDCUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OIDCUserClient) UpdateOneID(id int) *OIDCUserUpdateOne {
	mutation := newOIDCUserMutation(c.config, OpUpdateOne, withOIDCUserID(id))
	return &OIDCUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OIDCUser.
func (c *OIDCUserClient) Delete() *OIDCUserDelete {
	mutation := newOIDCUserMutation(c.config, OpDelete)
	return &OIDCUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OIDCUserClient) DeleteOne(ou *OIDCUser) *OIDCUserDeleteOne {
	return c.DeleteOneID(ou.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OIDCUserClient) DeleteOneID(id int) *OIDCUserDeleteOne {
	builder := c.Delete().Where(oidcuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OIDCUserDeleteOne{builder}
}

// Query returns a query builder for OIDCUser.
func (c *OIDCUserClient) Query() *OIDCUserQuery {
	return &OIDCUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOIDCUser},
		inters: c.Interceptors(),
	}
}

// Get returns a OIDCUser entity by its id.
func (c *OIDCUserClient) Get(ctx context.Context, id int) (*OIDCUser, error) {
	return c.Query().Where(oidcuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OIDCUserClient) GetX(ctx context.Context, id int) *OIDCUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a OIDCUser.
func (c *OIDCUserClient) QueryPermissions(ou *OIDCUser) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oidcuser.Table, oidcuser.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, oidcuser.PermissionsTable, oidcuser.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a OIDCUser.
func (c *OIDCUserClient) QueryTeams(ou *OIDCUser) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oidcuser.Table, oidcuser.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, oidcuser.TeamsTable, oidcuser.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OIDCUserClient) Hooks() []Hook {
	return c.hooks.OIDCUser
}

// Interceptors returns the client interceptors.
func (c *OIDCUserClient) Interceptors() []Interceptor {
	return c.inters.OIDCUser
}

func (c *OIDCUserClient) mutate(ctx context.Context, m *OIDCUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OIDCUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OIDCUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OIDCUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OIDCUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OIDCUser mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(pe *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(pe))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id int) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(pe *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id int) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id int) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id int) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeams queries the teams edge of a Permission.
func (c *PermissionClient) QueryTeams(pe *Permission) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.TeamsTable, permission.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLdapUsers queries the ldap_users edge of a Permission.
func (c *PermissionClient) QueryLdapUsers(pe *Permission) *LDAPUserQuery {
	query := (&LDAPUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(ldapuser.Table, ldapuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.LdapUsersTable, permission.LdapUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManagedUsers queries the managed_users edge of a Permission.
func (c *PermissionClient) QueryManagedUsers(pe *Permission) *ManagedUserQuery {
	query := (&ManagedUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(manageduser.Table, manageduser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.ManagedUsersTable, permission.ManagedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOidcUsers queries the oidc_users edge of a Permission.
func (c *PermissionClient) QueryOidcUsers(pe *Permission) *OIDCUserQuery {
	query := (&OIDCUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(oidcuser.Table, oidcuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.OidcUsersTable, permission.OidcUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	return c.hooks.Permission
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	return c.inters.Permission
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// SchemaVersionClient is a client for the SchemaVersion schema.
type SchemaVersionClient struct {
	config
}

// NewSchemaVersionClient returns a client for the SchemaVersion from the given config.
func NewSchemaVersionClient(c config) *SchemaVersionClient {
	return &SchemaVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schemaversion.Hooks(f(g(h())))`.
func (c *SchemaVersionClient) Use(hooks ...Hook) {
	c.hooks.SchemaVersion = append(c.hooks.SchemaVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schemaversion.Intercept(f(g(h())))`.
func (c *SchemaVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SchemaVersion = append(c.inters.SchemaVersion, interceptors...)
}

// Create returns a builder for creating a SchemaVersion entity.
func (c *SchemaVersionClient) Create() *SchemaVersionCreate {
	mutation := newSchemaVersionMutation(c.config, OpCreate)
	return &SchemaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SchemaVersion entities.
func (c *SchemaVersionClient) CreateBulk(builders ...*SchemaVersionCreate) *SchemaVersionCreateBulk {
	return &SchemaVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SchemaVersionClient) MapCreateBulk(slice any, setFunc func(*SchemaVersionCreate, int)) *SchemaVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SchemaVersionCreateBulk{err: fmt.Errorf("calling to SchemaVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SchemaVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SchemaVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SchemaVersion.
func (c *SchemaVersionClient) Update() *SchemaVersionUpdate {
	mutation := newSchemaVersionMutation(c.config, OpUpdate)
	return &SchemaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SchemaVersionClient) UpdateOne(sv *SchemaVersion) *SchemaVersionUpdateOne {
	mutation := newSchemaVersionMutation(c.config, OpUpdateOne, withSchemaVersion(sv))
	return &SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SchemaVersionClient) UpdateOneID(id int) *SchemaVersionUpdateOne {
	mutation := newSchemaVersionMutation(c.config, OpUpdateOne, withSchemaVersionID(id))
	return &SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SchemaVersion.
func (c *SchemaVersionClient) Delete() *SchemaVersionDelete {
	mutation := newSchemaVersionMutation(c.config, OpDelete)
	return &SchemaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SchemaVersionClient) DeleteOne(sv *SchemaVersion) *SchemaVersionDeleteOne {
	return c.DeleteOneID(sv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SchemaVersionClient) DeleteOneID(id int) *SchemaVersionDeleteOne {
	builder := c.Delete().Where(schemaversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SchemaVersionDeleteOne{builder}
}

// Query returns a query builder for SchemaVersion.
func (c *SchemaVersionClient) Query() *SchemaVersionQuery {
	return &SchemaVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSchemaVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a SchemaVersion entity by its id.
func (c *SchemaVersionClient) Get(ctx context.Context, id int) (*SchemaVersion, error) {
	return c.Query().Where(schemaversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SchemaVersionClient) GetX(ctx context.Context, id int) *SchemaVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SchemaVersionClient) Hooks() []Hook {
	return c.hooks.SchemaVersion
}

// Interceptors returns the client interceptors.
func (c *SchemaVersionClient) Interceptors() []Interceptor {
	return c.inters.SchemaVersion
}

func (c *SchemaVersionClient) mutate(ctx context.Context, m *SchemaVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SchemaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SchemaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SchemaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SchemaVersion mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id int) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id int) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id int) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id int) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAPIKeys queries the api_keys edge of a Team.
func (c *TeamClient) QueryAPIKeys(t *Team) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.APIKeysTable, team.APIKeysPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Team.
func (c *TeamClient) QueryPermissions(t *Team) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.PermissionsTable, team.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOidcGroups queries the oidc_groups edge of a Team.
func (c *TeamClient) QueryOidcGroups(t *Team) *OIDCGroupQuery {
	query := (&OIDCGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(oidcgroup.Table, oidcgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.OidcGroupsTable, team.OidcGroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedLdapGroups queries the mapped_ldap_groups edge of a Team.
func (c *TeamClient) QueryMappedLdapGroups(t *Team) *MappedLDAPGroupQuery {
	query := (&MappedLDAPGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(mappedldapgroup.Table, mappedldapgroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.MappedLdapGroupsTable, team.MappedLdapGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedOidcGroups queries the mapped_oidc_groups edge of a Team.
func (c *TeamClient) QueryMappedOidcGroups(t *Team) *MappedOIDCGroupQuery {
	query := (&MappedOIDCGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(mappedoidcgroup.Table, mappedoidcgroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.MappedOidcGroupsTable, team.MappedOidcGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLdapUsers queries the ldap_users edge of a Team.
func (c *TeamClient) QueryLdapUsers(t *Team) *LDAPUserQuery {
	query := (&LDAPUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(ldapuser.Table, ldapuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, team.LdapUsersTable, team.LdapUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManagedUsers queries the managed_users edge of a Team.
func (c *TeamClient) QueryManagedUsers(t *Team) *ManagedUserQuery {
	query := (&ManagedUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(manageduser.Table, manageduser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, team.ManagedUsersTable, team.ManagedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOidcUsers queries the oidc_users edge of a Team.
func (c *TeamClient) QueryOidcUsers(t *Team) *OIDCUserQuery {
	query := (&OIDCUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(oidcuser.Table, oidcuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, team.OidcUsersTable, team.OidcUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIKey, ConfigProperty, EventServiceLog, INSTALLEDUPGRADES, LDAPUser,
		ManagedUser, MappedLDAPGroup, MappedOIDCGroup, OIDCGroup, OIDCUser, Permission,
		SchemaVersion, Team []ent.Hook
	}
	inters struct {
		APIKey, ConfigProperty, EventServiceLog, INSTALLEDUPGRADES, LDAPUser,
		ManagedUser, MappedLDAPGroup, MappedOIDCGroup, OIDCGroup, OIDCUser, Permission,
		SchemaVersion, Team []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
