// Code generated by ent, DO NOT EDIT.
// --------------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2025 The DependencyTrack Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// --------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --------------------------------------------------------------------

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"dependencytrack.io/hyades/ent/apikey"
	"dependencytrack.io/hyades/ent/configproperty"
	"dependencytrack.io/hyades/ent/eventservicelog"
	"dependencytrack.io/hyades/ent/installedupgrades"
	"dependencytrack.io/hyades/ent/ldapuser"
	"dependencytrack.io/hyades/ent/manageduser"
	"dependencytrack.io/hyades/ent/mappedldapgroup"
	"dependencytrack.io/hyades/ent/mappedoidcgroup"
	"dependencytrack.io/hyades/ent/oidcgroup"
	"dependencytrack.io/hyades/ent/oidcuser"
	"dependencytrack.io/hyades/ent/permission"
	"dependencytrack.io/hyades/ent/predicate"
	"dependencytrack.io/hyades/ent/schemaversion"
	"dependencytrack.io/hyades/ent/team"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey            = "APIKey"
	TypeConfigProperty    = "ConfigProperty"
	TypeEventServiceLog   = "EventServiceLog"
	TypeINSTALLEDUPGRADES = "INSTALLEDUPGRADES"
	TypeLDAPUser          = "LDAPUser"
	TypeManagedUser       = "ManagedUser"
	TypeMappedLDAPGroup   = "MappedLDAPGroup"
	TypeMappedOIDCGroup   = "MappedOIDCGroup"
	TypeOIDCGroup         = "OIDCGroup"
	TypeOIDCUser          = "OIDCUser"
	TypePermission        = "Permission"
	TypeSchemaVersion     = "SchemaVersion"
	TypeTeam              = "Team"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	apikey        *string
	comment       *string
	created       *time.Time
	last_used     *time.Time
	is_legacy     *bool
	public_id     *string
	clearedFields map[string]struct{}
	teams         map[int]struct{}
	removedteams  map[int]struct{}
	clearedteams  bool
	done          bool
	oldValue      func(context.Context) (*APIKey, error)
	predicates    []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApikey sets the "apikey" field.
func (m *APIKeyMutation) SetApikey(s string) {
	m.apikey = &s
}

// Apikey returns the value of the "apikey" field in the mutation.
func (m *APIKeyMutation) Apikey() (r string, exists bool) {
	v := m.apikey
	if v == nil {
		return
	}
	return *v, true
}

// OldApikey returns the old "apikey" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldApikey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApikey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApikey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApikey: %w", err)
	}
	return oldValue.Apikey, nil
}

// ResetApikey resets all changes to the "apikey" field.
func (m *APIKeyMutation) ResetApikey() {
	m.apikey = nil
}

// SetComment sets the "comment" field.
func (m *APIKeyMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *APIKeyMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *APIKeyMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[apikey.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *APIKeyMutation) CommentCleared() bool {
	_, ok := m.clearedFields[apikey.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *APIKeyMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, apikey.FieldComment)
}

// SetCreated sets the "created" field.
func (m *APIKeyMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *APIKeyMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *APIKeyMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[apikey.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *APIKeyMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[apikey.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *APIKeyMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, apikey.FieldCreated)
}

// SetLastUsed sets the "last_used" field.
func (m *APIKeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *APIKeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *APIKeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[apikey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *APIKeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, apikey.FieldLastUsed)
}

// SetIsLegacy sets the "is_legacy" field.
func (m *APIKeyMutation) SetIsLegacy(b bool) {
	m.is_legacy = &b
}

// IsLegacy returns the value of the "is_legacy" field in the mutation.
func (m *APIKeyMutation) IsLegacy() (r bool, exists bool) {
	v := m.is_legacy
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLegacy returns the old "is_legacy" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldIsLegacy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLegacy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLegacy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLegacy: %w", err)
	}
	return oldValue.IsLegacy, nil
}

// ResetIsLegacy resets all changes to the "is_legacy" field.
func (m *APIKeyMutation) ResetIsLegacy() {
	m.is_legacy = nil
}

// SetPublicID sets the "public_id" field.
func (m *APIKeyMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *APIKeyMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ClearPublicID clears the value of the "public_id" field.
func (m *APIKeyMutation) ClearPublicID() {
	m.public_id = nil
	m.clearedFields[apikey.FieldPublicID] = struct{}{}
}

// PublicIDCleared returns if the "public_id" field was cleared in this mutation.
func (m *APIKeyMutation) PublicIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldPublicID]
	return ok
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *APIKeyMutation) ResetPublicID() {
	m.public_id = nil
	delete(m.clearedFields, apikey.FieldPublicID)
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *APIKeyMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *APIKeyMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *APIKeyMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *APIKeyMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *APIKeyMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *APIKeyMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *APIKeyMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.apikey != nil {
		fields = append(fields, apikey.FieldApikey)
	}
	if m.comment != nil {
		fields = append(fields, apikey.FieldComment)
	}
	if m.created != nil {
		fields = append(fields, apikey.FieldCreated)
	}
	if m.last_used != nil {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.is_legacy != nil {
		fields = append(fields, apikey.FieldIsLegacy)
	}
	if m.public_id != nil {
		fields = append(fields, apikey.FieldPublicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldApikey:
		return m.Apikey()
	case apikey.FieldComment:
		return m.Comment()
	case apikey.FieldCreated:
		return m.Created()
	case apikey.FieldLastUsed:
		return m.LastUsed()
	case apikey.FieldIsLegacy:
		return m.IsLegacy()
	case apikey.FieldPublicID:
		return m.PublicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldApikey:
		return m.OldApikey(ctx)
	case apikey.FieldComment:
		return m.OldComment(ctx)
	case apikey.FieldCreated:
		return m.OldCreated(ctx)
	case apikey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case apikey.FieldIsLegacy:
		return m.OldIsLegacy(ctx)
	case apikey.FieldPublicID:
		return m.OldPublicID(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldApikey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApikey(v)
		return nil
	case apikey.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case apikey.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case apikey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case apikey.FieldIsLegacy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLegacy(v)
		return nil
	case apikey.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldComment) {
		fields = append(fields, apikey.FieldComment)
	}
	if m.FieldCleared(apikey.FieldCreated) {
		fields = append(fields, apikey.FieldCreated)
	}
	if m.FieldCleared(apikey.FieldLastUsed) {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.FieldCleared(apikey.FieldPublicID) {
		fields = append(fields, apikey.FieldPublicID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldComment:
		m.ClearComment()
		return nil
	case apikey.FieldCreated:
		m.ClearCreated()
		return nil
	case apikey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case apikey.FieldPublicID:
		m.ClearPublicID()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldApikey:
		m.ResetApikey()
		return nil
	case apikey.FieldComment:
		m.ResetComment()
		return nil
	case apikey.FieldCreated:
		m.ResetCreated()
		return nil
	case apikey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case apikey.FieldIsLegacy:
		m.ResetIsLegacy()
		return nil
	case apikey.FieldPublicID:
		m.ResetPublicID()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.teams != nil {
		edges = append(edges, apikey.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedteams != nil {
		edges = append(edges, apikey.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteams {
		edges = append(edges, apikey.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// ConfigPropertyMutation represents an operation that mutates the ConfigProperty nodes in the graph.
type ConfigPropertyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	description   *string
	groupname     *string
	propertyname  *string
	propertytype  *string
	propertyvalue *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConfigProperty, error)
	predicates    []predicate.ConfigProperty
}

var _ ent.Mutation = (*ConfigPropertyMutation)(nil)

// configpropertyOption allows management of the mutation configuration using functional options.
type configpropertyOption func(*ConfigPropertyMutation)

// newConfigPropertyMutation creates new mutation for the ConfigProperty entity.
func newConfigPropertyMutation(c config, op Op, opts ...configpropertyOption) *ConfigPropertyMutation {
	m := &ConfigPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigPropertyID sets the ID field of the mutation.
func withConfigPropertyID(id int) configpropertyOption {
	return func(m *ConfigPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigProperty
		)
		m.oldValue = func(ctx context.Context) (*ConfigProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigProperty sets the old ConfigProperty of the mutation.
func withConfigProperty(node *ConfigProperty) configpropertyOption {
	return func(m *ConfigPropertyMutation) {
		m.oldValue = func(context.Context) (*ConfigProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigPropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigPropertyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *ConfigPropertyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigPropertyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigProperty entity.
// If the ConfigProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigPropertyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigPropertyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configproperty.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigPropertyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configproperty.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigPropertyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configproperty.FieldDescription)
}

// SetGroupname sets the "groupname" field.
func (m *ConfigPropertyMutation) SetGroupname(s string) {
	m.groupname = &s
}

// Groupname returns the value of the "groupname" field in the mutation.
func (m *ConfigPropertyMutation) Groupname() (r string, exists bool) {
	v := m.groupname
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupname returns the old "groupname" field's value of the ConfigProperty entity.
// If the ConfigProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigPropertyMutation) OldGroupname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupname: %w", err)
	}
	return oldValue.Groupname, nil
}

// ResetGroupname resets all changes to the "groupname" field.
func (m *ConfigPropertyMutation) ResetGroupname() {
	m.groupname = nil
}

// SetPropertyname sets the "propertyname" field.
func (m *ConfigPropertyMutation) SetPropertyname(s string) {
	m.propertyname = &s
}

// Propertyname returns the value of the "propertyname" field in the mutation.
func (m *ConfigPropertyMutation) Propertyname() (r string, exists bool) {
	v := m.propertyname
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyname returns the old "propertyname" field's value of the ConfigProperty entity.
// If the ConfigProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigPropertyMutation) OldPropertyname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyname: %w", err)
	}
	return oldValue.Propertyname, nil
}

// ResetPropertyname resets all changes to the "propertyname" field.
func (m *ConfigPropertyMutation) ResetPropertyname() {
	m.propertyname = nil
}

// SetPropertytype sets the "propertytype" field.
func (m *ConfigPropertyMutation) SetPropertytype(s string) {
	m.propertytype = &s
}

// Propertytype returns the value of the "propertytype" field in the mutation.
func (m *ConfigPropertyMutation) Propertytype() (r string, exists bool) {
	v := m.propertytype
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertytype returns the old "propertytype" field's value of the ConfigProperty entity.
// If the ConfigProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigPropertyMutation) OldPropertytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertytype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertytype: %w", err)
	}
	return oldValue.Propertytype, nil
}

// ResetPropertytype resets all changes to the "propertytype" field.
func (m *ConfigPropertyMutation) ResetPropertytype() {
	m.propertytype = nil
}

// SetPropertyvalue sets the "propertyvalue" field.
func (m *ConfigPropertyMutation) SetPropertyvalue(s string) {
	m.propertyvalue = &s
}

// Propertyvalue returns the value of the "propertyvalue" field in the mutation.
func (m *ConfigPropertyMutation) Propertyvalue() (r string, exists bool) {
	v := m.propertyvalue
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyvalue returns the old "propertyvalue" field's value of the ConfigProperty entity.
// If the ConfigProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigPropertyMutation) OldPropertyvalue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyvalue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyvalue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyvalue: %w", err)
	}
	return oldValue.Propertyvalue, nil
}

// ClearPropertyvalue clears the value of the "propertyvalue" field.
func (m *ConfigPropertyMutation) ClearPropertyvalue() {
	m.propertyvalue = nil
	m.clearedFields[configproperty.FieldPropertyvalue] = struct{}{}
}

// PropertyvalueCleared returns if the "propertyvalue" field was cleared in this mutation.
func (m *ConfigPropertyMutation) PropertyvalueCleared() bool {
	_, ok := m.clearedFields[configproperty.FieldPropertyvalue]
	return ok
}

// ResetPropertyvalue resets all changes to the "propertyvalue" field.
func (m *ConfigPropertyMutation) ResetPropertyvalue() {
	m.propertyvalue = nil
	delete(m.clearedFields, configproperty.FieldPropertyvalue)
}

// Where appends a list predicates to the ConfigPropertyMutation builder.
func (m *ConfigPropertyMutation) Where(ps ...predicate.ConfigProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigProperty).
func (m *ConfigPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigPropertyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.description != nil {
		fields = append(fields, configproperty.FieldDescription)
	}
	if m.groupname != nil {
		fields = append(fields, configproperty.FieldGroupname)
	}
	if m.propertyname != nil {
		fields = append(fields, configproperty.FieldPropertyname)
	}
	if m.propertytype != nil {
		fields = append(fields, configproperty.FieldPropertytype)
	}
	if m.propertyvalue != nil {
		fields = append(fields, configproperty.FieldPropertyvalue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configproperty.FieldDescription:
		return m.Description()
	case configproperty.FieldGroupname:
		return m.Groupname()
	case configproperty.FieldPropertyname:
		return m.Propertyname()
	case configproperty.FieldPropertytype:
		return m.Propertytype()
	case configproperty.FieldPropertyvalue:
		return m.Propertyvalue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configproperty.FieldDescription:
		return m.OldDescription(ctx)
	case configproperty.FieldGroupname:
		return m.OldGroupname(ctx)
	case configproperty.FieldPropertyname:
		return m.OldPropertyname(ctx)
	case configproperty.FieldPropertytype:
		return m.OldPropertytype(ctx)
	case configproperty.FieldPropertyvalue:
		return m.OldPropertyvalue(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configproperty.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configproperty.FieldGroupname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupname(v)
		return nil
	case configproperty.FieldPropertyname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyname(v)
		return nil
	case configproperty.FieldPropertytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertytype(v)
		return nil
	case configproperty.FieldPropertyvalue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyvalue(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigPropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigPropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConfigProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configproperty.FieldDescription) {
		fields = append(fields, configproperty.FieldDescription)
	}
	if m.FieldCleared(configproperty.FieldPropertyvalue) {
		fields = append(fields, configproperty.FieldPropertyvalue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigPropertyMutation) ClearField(name string) error {
	switch name {
	case configproperty.FieldDescription:
		m.ClearDescription()
		return nil
	case configproperty.FieldPropertyvalue:
		m.ClearPropertyvalue()
		return nil
	}
	return fmt.Errorf("unknown ConfigProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigPropertyMutation) ResetField(name string) error {
	switch name {
	case configproperty.FieldDescription:
		m.ResetDescription()
		return nil
	case configproperty.FieldGroupname:
		m.ResetGroupname()
		return nil
	case configproperty.FieldPropertyname:
		m.ResetPropertyname()
		return nil
	case configproperty.FieldPropertytype:
		m.ResetPropertytype()
		return nil
	case configproperty.FieldPropertyvalue:
		m.ResetPropertyvalue()
		return nil
	}
	return fmt.Errorf("unknown ConfigProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigPropertyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigPropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigPropertyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigPropertyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigPropertyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigProperty edge %s", name)
}

// EventServiceLogMutation represents an operation that mutates the EventServiceLog nodes in the graph.
type EventServiceLogMutation struct {
	config
	op              Op
	typ             string
	id              *int
	subscriberclass *string
	started         *time.Time
	completed       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*EventServiceLog, error)
	predicates      []predicate.EventServiceLog
}

var _ ent.Mutation = (*EventServiceLogMutation)(nil)

// eventservicelogOption allows management of the mutation configuration using functional options.
type eventservicelogOption func(*EventServiceLogMutation)

// newEventServiceLogMutation creates new mutation for the EventServiceLog entity.
func newEventServiceLogMutation(c config, op Op, opts ...eventservicelogOption) *EventServiceLogMutation {
	m := &EventServiceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeEventServiceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventServiceLogID sets the ID field of the mutation.
func withEventServiceLogID(id int) eventservicelogOption {
	return func(m *EventServiceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *EventServiceLog
		)
		m.oldValue = func(ctx context.Context) (*EventServiceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventServiceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventServiceLog sets the old EventServiceLog of the mutation.
func withEventServiceLog(node *EventServiceLog) eventservicelogOption {
	return func(m *EventServiceLogMutation) {
		m.oldValue = func(context.Context) (*EventServiceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventServiceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventServiceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventServiceLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventServiceLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventServiceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubscriberclass sets the "subscriberclass" field.
func (m *EventServiceLogMutation) SetSubscriberclass(s string) {
	m.subscriberclass = &s
}

// Subscriberclass returns the value of the "subscriberclass" field in the mutation.
func (m *EventServiceLogMutation) Subscriberclass() (r string, exists bool) {
	v := m.subscriberclass
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriberclass returns the old "subscriberclass" field's value of the EventServiceLog entity.
// If the EventServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventServiceLogMutation) OldSubscriberclass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriberclass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriberclass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriberclass: %w", err)
	}
	return oldValue.Subscriberclass, nil
}

// ResetSubscriberclass resets all changes to the "subscriberclass" field.
func (m *EventServiceLogMutation) ResetSubscriberclass() {
	m.subscriberclass = nil
}

// SetStarted sets the "started" field.
func (m *EventServiceLogMutation) SetStarted(t time.Time) {
	m.started = &t
}

// Started returns the value of the "started" field in the mutation.
func (m *EventServiceLogMutation) Started() (r time.Time, exists bool) {
	v := m.started
	if v == nil {
		return
	}
	return *v, true
}

// OldStarted returns the old "started" field's value of the EventServiceLog entity.
// If the EventServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventServiceLogMutation) OldStarted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarted: %w", err)
	}
	return oldValue.Started, nil
}

// ClearStarted clears the value of the "started" field.
func (m *EventServiceLogMutation) ClearStarted() {
	m.started = nil
	m.clearedFields[eventservicelog.FieldStarted] = struct{}{}
}

// StartedCleared returns if the "started" field was cleared in this mutation.
func (m *EventServiceLogMutation) StartedCleared() bool {
	_, ok := m.clearedFields[eventservicelog.FieldStarted]
	return ok
}

// ResetStarted resets all changes to the "started" field.
func (m *EventServiceLogMutation) ResetStarted() {
	m.started = nil
	delete(m.clearedFields, eventservicelog.FieldStarted)
}

// SetCompleted sets the "completed" field.
func (m *EventServiceLogMutation) SetCompleted(t time.Time) {
	m.completed = &t
}

// Completed returns the value of the "completed" field in the mutation.
func (m *EventServiceLogMutation) Completed() (r time.Time, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the EventServiceLog entity.
// If the EventServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventServiceLogMutation) OldCompleted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ClearCompleted clears the value of the "completed" field.
func (m *EventServiceLogMutation) ClearCompleted() {
	m.completed = nil
	m.clearedFields[eventservicelog.FieldCompleted] = struct{}{}
}

// CompletedCleared returns if the "completed" field was cleared in this mutation.
func (m *EventServiceLogMutation) CompletedCleared() bool {
	_, ok := m.clearedFields[eventservicelog.FieldCompleted]
	return ok
}

// ResetCompleted resets all changes to the "completed" field.
func (m *EventServiceLogMutation) ResetCompleted() {
	m.completed = nil
	delete(m.clearedFields, eventservicelog.FieldCompleted)
}

// Where appends a list predicates to the EventServiceLogMutation builder.
func (m *EventServiceLogMutation) Where(ps ...predicate.EventServiceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventServiceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventServiceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventServiceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventServiceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventServiceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventServiceLog).
func (m *EventServiceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventServiceLogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.subscriberclass != nil {
		fields = append(fields, eventservicelog.FieldSubscriberclass)
	}
	if m.started != nil {
		fields = append(fields, eventservicelog.FieldStarted)
	}
	if m.completed != nil {
		fields = append(fields, eventservicelog.FieldCompleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventServiceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventservicelog.FieldSubscriberclass:
		return m.Subscriberclass()
	case eventservicelog.FieldStarted:
		return m.Started()
	case eventservicelog.FieldCompleted:
		return m.Completed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventServiceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventservicelog.FieldSubscriberclass:
		return m.OldSubscriberclass(ctx)
	case eventservicelog.FieldStarted:
		return m.OldStarted(ctx)
	case eventservicelog.FieldCompleted:
		return m.OldCompleted(ctx)
	}
	return nil, fmt.Errorf("unknown EventServiceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventServiceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventservicelog.FieldSubscriberclass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriberclass(v)
		return nil
	case eventservicelog.FieldStarted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarted(v)
		return nil
	case eventservicelog.FieldCompleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown EventServiceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventServiceLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventServiceLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventServiceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventServiceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventServiceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventservicelog.FieldStarted) {
		fields = append(fields, eventservicelog.FieldStarted)
	}
	if m.FieldCleared(eventservicelog.FieldCompleted) {
		fields = append(fields, eventservicelog.FieldCompleted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventServiceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventServiceLogMutation) ClearField(name string) error {
	switch name {
	case eventservicelog.FieldStarted:
		m.ClearStarted()
		return nil
	case eventservicelog.FieldCompleted:
		m.ClearCompleted()
		return nil
	}
	return fmt.Errorf("unknown EventServiceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventServiceLogMutation) ResetField(name string) error {
	switch name {
	case eventservicelog.FieldSubscriberclass:
		m.ResetSubscriberclass()
		return nil
	case eventservicelog.FieldStarted:
		m.ResetStarted()
		return nil
	case eventservicelog.FieldCompleted:
		m.ResetCompleted()
		return nil
	}
	return fmt.Errorf("unknown EventServiceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventServiceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventServiceLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventServiceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventServiceLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventServiceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventServiceLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventServiceLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EventServiceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventServiceLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EventServiceLog edge %s", name)
}

// INSTALLEDUPGRADESMutation represents an operation that mutates the INSTALLEDUPGRADES nodes in the graph.
type INSTALLEDUPGRADESMutation struct {
	config
	op            Op
	typ           string
	id            *int
	endtime       *time.Time
	starttime     *time.Time
	upgradeclass  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*INSTALLEDUPGRADES, error)
	predicates    []predicate.INSTALLEDUPGRADES
}

var _ ent.Mutation = (*INSTALLEDUPGRADESMutation)(nil)

// installedupgradesOption allows management of the mutation configuration using functional options.
type installedupgradesOption func(*INSTALLEDUPGRADESMutation)

// newINSTALLEDUPGRADESMutation creates new mutation for the INSTALLEDUPGRADES entity.
func newINSTALLEDUPGRADESMutation(c config, op Op, opts ...installedupgradesOption) *INSTALLEDUPGRADESMutation {
	m := &INSTALLEDUPGRADESMutation{
		config:        c,
		op:            op,
		typ:           TypeINSTALLEDUPGRADES,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withINSTALLEDUPGRADESID sets the ID field of the mutation.
func withINSTALLEDUPGRADESID(id int) installedupgradesOption {
	return func(m *INSTALLEDUPGRADESMutation) {
		var (
			err   error
			once  sync.Once
			value *INSTALLEDUPGRADES
		)
		m.oldValue = func(ctx context.Context) (*INSTALLEDUPGRADES, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().INSTALLEDUPGRADES.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withINSTALLEDUPGRADES sets the old INSTALLEDUPGRADES of the mutation.
func withINSTALLEDUPGRADES(node *INSTALLEDUPGRADES) installedupgradesOption {
	return func(m *INSTALLEDUPGRADESMutation) {
		m.oldValue = func(context.Context) (*INSTALLEDUPGRADES, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m INSTALLEDUPGRADESMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m INSTALLEDUPGRADESMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *INSTALLEDUPGRADESMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *INSTALLEDUPGRADESMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().INSTALLEDUPGRADES.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndtime sets the "endtime" field.
func (m *INSTALLEDUPGRADESMutation) SetEndtime(t time.Time) {
	m.endtime = &t
}

// Endtime returns the value of the "endtime" field in the mutation.
func (m *INSTALLEDUPGRADESMutation) Endtime() (r time.Time, exists bool) {
	v := m.endtime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndtime returns the old "endtime" field's value of the INSTALLEDUPGRADES entity.
// If the INSTALLEDUPGRADES object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *INSTALLEDUPGRADESMutation) OldEndtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndtime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndtime: %w", err)
	}
	return oldValue.Endtime, nil
}

// ClearEndtime clears the value of the "endtime" field.
func (m *INSTALLEDUPGRADESMutation) ClearEndtime() {
	m.endtime = nil
	m.clearedFields[installedupgrades.FieldEndtime] = struct{}{}
}

// EndtimeCleared returns if the "endtime" field was cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) EndtimeCleared() bool {
	_, ok := m.clearedFields[installedupgrades.FieldEndtime]
	return ok
}

// ResetEndtime resets all changes to the "endtime" field.
func (m *INSTALLEDUPGRADESMutation) ResetEndtime() {
	m.endtime = nil
	delete(m.clearedFields, installedupgrades.FieldEndtime)
}

// SetStarttime sets the "starttime" field.
func (m *INSTALLEDUPGRADESMutation) SetStarttime(t time.Time) {
	m.starttime = &t
}

// Starttime returns the value of the "starttime" field in the mutation.
func (m *INSTALLEDUPGRADESMutation) Starttime() (r time.Time, exists bool) {
	v := m.starttime
	if v == nil {
		return
	}
	return *v, true
}

// OldStarttime returns the old "starttime" field's value of the INSTALLEDUPGRADES entity.
// If the INSTALLEDUPGRADES object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *INSTALLEDUPGRADESMutation) OldStarttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarttime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarttime: %w", err)
	}
	return oldValue.Starttime, nil
}

// ClearStarttime clears the value of the "starttime" field.
func (m *INSTALLEDUPGRADESMutation) ClearStarttime() {
	m.starttime = nil
	m.clearedFields[installedupgrades.FieldStarttime] = struct{}{}
}

// StarttimeCleared returns if the "starttime" field was cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) StarttimeCleared() bool {
	_, ok := m.clearedFields[installedupgrades.FieldStarttime]
	return ok
}

// ResetStarttime resets all changes to the "starttime" field.
func (m *INSTALLEDUPGRADESMutation) ResetStarttime() {
	m.starttime = nil
	delete(m.clearedFields, installedupgrades.FieldStarttime)
}

// SetUpgradeclass sets the "upgradeclass" field.
func (m *INSTALLEDUPGRADESMutation) SetUpgradeclass(s string) {
	m.upgradeclass = &s
}

// Upgradeclass returns the value of the "upgradeclass" field in the mutation.
func (m *INSTALLEDUPGRADESMutation) Upgradeclass() (r string, exists bool) {
	v := m.upgradeclass
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeclass returns the old "upgradeclass" field's value of the INSTALLEDUPGRADES entity.
// If the INSTALLEDUPGRADES object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *INSTALLEDUPGRADESMutation) OldUpgradeclass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeclass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeclass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeclass: %w", err)
	}
	return oldValue.Upgradeclass, nil
}

// ClearUpgradeclass clears the value of the "upgradeclass" field.
func (m *INSTALLEDUPGRADESMutation) ClearUpgradeclass() {
	m.upgradeclass = nil
	m.clearedFields[installedupgrades.FieldUpgradeclass] = struct{}{}
}

// UpgradeclassCleared returns if the "upgradeclass" field was cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) UpgradeclassCleared() bool {
	_, ok := m.clearedFields[installedupgrades.FieldUpgradeclass]
	return ok
}

// ResetUpgradeclass resets all changes to the "upgradeclass" field.
func (m *INSTALLEDUPGRADESMutation) ResetUpgradeclass() {
	m.upgradeclass = nil
	delete(m.clearedFields, installedupgrades.FieldUpgradeclass)
}

// Where appends a list predicates to the INSTALLEDUPGRADESMutation builder.
func (m *INSTALLEDUPGRADESMutation) Where(ps ...predicate.INSTALLEDUPGRADES) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the INSTALLEDUPGRADESMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *INSTALLEDUPGRADESMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.INSTALLEDUPGRADES, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *INSTALLEDUPGRADESMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *INSTALLEDUPGRADESMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (INSTALLEDUPGRADES).
func (m *INSTALLEDUPGRADESMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *INSTALLEDUPGRADESMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.endtime != nil {
		fields = append(fields, installedupgrades.FieldEndtime)
	}
	if m.starttime != nil {
		fields = append(fields, installedupgrades.FieldStarttime)
	}
	if m.upgradeclass != nil {
		fields = append(fields, installedupgrades.FieldUpgradeclass)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *INSTALLEDUPGRADESMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case installedupgrades.FieldEndtime:
		return m.Endtime()
	case installedupgrades.FieldStarttime:
		return m.Starttime()
	case installedupgrades.FieldUpgradeclass:
		return m.Upgradeclass()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *INSTALLEDUPGRADESMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case installedupgrades.FieldEndtime:
		return m.OldEndtime(ctx)
	case installedupgrades.FieldStarttime:
		return m.OldStarttime(ctx)
	case installedupgrades.FieldUpgradeclass:
		return m.OldUpgradeclass(ctx)
	}
	return nil, fmt.Errorf("unknown INSTALLEDUPGRADES field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *INSTALLEDUPGRADESMutation) SetField(name string, value ent.Value) error {
	switch name {
	case installedupgrades.FieldEndtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndtime(v)
		return nil
	case installedupgrades.FieldStarttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarttime(v)
		return nil
	case installedupgrades.FieldUpgradeclass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeclass(v)
		return nil
	}
	return fmt.Errorf("unknown INSTALLEDUPGRADES field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *INSTALLEDUPGRADESMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *INSTALLEDUPGRADESMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *INSTALLEDUPGRADESMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown INSTALLEDUPGRADES numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *INSTALLEDUPGRADESMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(installedupgrades.FieldEndtime) {
		fields = append(fields, installedupgrades.FieldEndtime)
	}
	if m.FieldCleared(installedupgrades.FieldStarttime) {
		fields = append(fields, installedupgrades.FieldStarttime)
	}
	if m.FieldCleared(installedupgrades.FieldUpgradeclass) {
		fields = append(fields, installedupgrades.FieldUpgradeclass)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *INSTALLEDUPGRADESMutation) ClearField(name string) error {
	switch name {
	case installedupgrades.FieldEndtime:
		m.ClearEndtime()
		return nil
	case installedupgrades.FieldStarttime:
		m.ClearStarttime()
		return nil
	case installedupgrades.FieldUpgradeclass:
		m.ClearUpgradeclass()
		return nil
	}
	return fmt.Errorf("unknown INSTALLEDUPGRADES nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *INSTALLEDUPGRADESMutation) ResetField(name string) error {
	switch name {
	case installedupgrades.FieldEndtime:
		m.ResetEndtime()
		return nil
	case installedupgrades.FieldStarttime:
		m.ResetStarttime()
		return nil
	case installedupgrades.FieldUpgradeclass:
		m.ResetUpgradeclass()
		return nil
	}
	return fmt.Errorf("unknown INSTALLEDUPGRADES field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *INSTALLEDUPGRADESMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *INSTALLEDUPGRADESMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *INSTALLEDUPGRADESMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *INSTALLEDUPGRADESMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *INSTALLEDUPGRADESMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *INSTALLEDUPGRADESMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown INSTALLEDUPGRADES unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *INSTALLEDUPGRADESMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown INSTALLEDUPGRADES edge %s", name)
}

// LDAPUserMutation represents an operation that mutates the LDAPUser nodes in the graph.
type LDAPUserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	dn                 *string
	email              *string
	username           *string
	clearedFields      map[string]struct{}
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	teams              map[int]struct{}
	removedteams       map[int]struct{}
	clearedteams       bool
	done               bool
	oldValue           func(context.Context) (*LDAPUser, error)
	predicates         []predicate.LDAPUser
}

var _ ent.Mutation = (*LDAPUserMutation)(nil)

// ldapuserOption allows management of the mutation configuration using functional options.
type ldapuserOption func(*LDAPUserMutation)

// newLDAPUserMutation creates new mutation for the LDAPUser entity.
func newLDAPUserMutation(c config, op Op, opts ...ldapuserOption) *LDAPUserMutation {
	m := &LDAPUserMutation{
		config:        c,
		op:            op,
		typ:           TypeLDAPUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLDAPUserID sets the ID field of the mutation.
func withLDAPUserID(id int) ldapuserOption {
	return func(m *LDAPUserMutation) {
		var (
			err   error
			once  sync.Once
			value *LDAPUser
		)
		m.oldValue = func(ctx context.Context) (*LDAPUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LDAPUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLDAPUser sets the old LDAPUser of the mutation.
func withLDAPUser(node *LDAPUser) ldapuserOption {
	return func(m *LDAPUserMutation) {
		m.oldValue = func(context.Context) (*LDAPUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LDAPUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LDAPUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LDAPUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LDAPUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LDAPUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDn sets the "dn" field.
func (m *LDAPUserMutation) SetDn(s string) {
	m.dn = &s
}

// Dn returns the value of the "dn" field in the mutation.
func (m *LDAPUserMutation) Dn() (r string, exists bool) {
	v := m.dn
	if v == nil {
		return
	}
	return *v, true
}

// OldDn returns the old "dn" field's value of the LDAPUser entity.
// If the LDAPUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LDAPUserMutation) OldDn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDn: %w", err)
	}
	return oldValue.Dn, nil
}

// ResetDn resets all changes to the "dn" field.
func (m *LDAPUserMutation) ResetDn() {
	m.dn = nil
}

// SetEmail sets the "email" field.
func (m *LDAPUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LDAPUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the LDAPUser entity.
// If the LDAPUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LDAPUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *LDAPUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[ldapuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *LDAPUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[ldapuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *LDAPUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, ldapuser.FieldEmail)
}

// SetUsername sets the "username" field.
func (m *LDAPUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *LDAPUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the LDAPUser entity.
// If the LDAPUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LDAPUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *LDAPUserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[ldapuser.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *LDAPUserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[ldapuser.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *LDAPUserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, ldapuser.FieldUsername)
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *LDAPUserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *LDAPUserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *LDAPUserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *LDAPUserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *LDAPUserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *LDAPUserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *LDAPUserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *LDAPUserMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *LDAPUserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *LDAPUserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *LDAPUserMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *LDAPUserMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *LDAPUserMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *LDAPUserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the LDAPUserMutation builder.
func (m *LDAPUserMutation) Where(ps ...predicate.LDAPUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LDAPUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LDAPUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LDAPUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LDAPUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LDAPUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LDAPUser).
func (m *LDAPUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LDAPUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.dn != nil {
		fields = append(fields, ldapuser.FieldDn)
	}
	if m.email != nil {
		fields = append(fields, ldapuser.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, ldapuser.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LDAPUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ldapuser.FieldDn:
		return m.Dn()
	case ldapuser.FieldEmail:
		return m.Email()
	case ldapuser.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LDAPUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ldapuser.FieldDn:
		return m.OldDn(ctx)
	case ldapuser.FieldEmail:
		return m.OldEmail(ctx)
	case ldapuser.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown LDAPUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LDAPUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ldapuser.FieldDn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDn(v)
		return nil
	case ldapuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case ldapuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown LDAPUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LDAPUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LDAPUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LDAPUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LDAPUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LDAPUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ldapuser.FieldEmail) {
		fields = append(fields, ldapuser.FieldEmail)
	}
	if m.FieldCleared(ldapuser.FieldUsername) {
		fields = append(fields, ldapuser.FieldUsername)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LDAPUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LDAPUserMutation) ClearField(name string) error {
	switch name {
	case ldapuser.FieldEmail:
		m.ClearEmail()
		return nil
	case ldapuser.FieldUsername:
		m.ClearUsername()
		return nil
	}
	return fmt.Errorf("unknown LDAPUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LDAPUserMutation) ResetField(name string) error {
	switch name {
	case ldapuser.FieldDn:
		m.ResetDn()
		return nil
	case ldapuser.FieldEmail:
		m.ResetEmail()
		return nil
	case ldapuser.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown LDAPUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LDAPUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.permissions != nil {
		edges = append(edges, ldapuser.EdgePermissions)
	}
	if m.teams != nil {
		edges = append(edges, ldapuser.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LDAPUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ldapuser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case ldapuser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LDAPUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpermissions != nil {
		edges = append(edges, ldapuser.EdgePermissions)
	}
	if m.removedteams != nil {
		edges = append(edges, ldapuser.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LDAPUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ldapuser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case ldapuser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LDAPUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpermissions {
		edges = append(edges, ldapuser.EdgePermissions)
	}
	if m.clearedteams {
		edges = append(edges, ldapuser.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LDAPUserMutation) EdgeCleared(name string) bool {
	switch name {
	case ldapuser.EdgePermissions:
		return m.clearedpermissions
	case ldapuser.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LDAPUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LDAPUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LDAPUserMutation) ResetEdge(name string) error {
	switch name {
	case ldapuser.EdgePermissions:
		m.ResetPermissions()
		return nil
	case ldapuser.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown LDAPUser edge %s", name)
}

// ManagedUserMutation represents an operation that mutates the ManagedUser nodes in the graph.
type ManagedUserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	email                 *string
	force_password_change *bool
	fullname              *string
	last_password_change  *time.Time
	non_expiry_password   *bool
	password              *string
	suspended             *bool
	username              *string
	clearedFields         map[string]struct{}
	permissions           map[int]struct{}
	removedpermissions    map[int]struct{}
	clearedpermissions    bool
	teams                 map[int]struct{}
	removedteams          map[int]struct{}
	clearedteams          bool
	done                  bool
	oldValue              func(context.Context) (*ManagedUser, error)
	predicates            []predicate.ManagedUser
}

var _ ent.Mutation = (*ManagedUserMutation)(nil)

// manageduserOption allows management of the mutation configuration using functional options.
type manageduserOption func(*ManagedUserMutation)

// newManagedUserMutation creates new mutation for the ManagedUser entity.
func newManagedUserMutation(c config, op Op, opts ...manageduserOption) *ManagedUserMutation {
	m := &ManagedUserMutation{
		config:        c,
		op:            op,
		typ:           TypeManagedUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManagedUserID sets the ID field of the mutation.
func withManagedUserID(id int) manageduserOption {
	return func(m *ManagedUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ManagedUser
		)
		m.oldValue = func(ctx context.Context) (*ManagedUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ManagedUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManagedUser sets the old ManagedUser of the mutation.
func withManagedUser(node *ManagedUser) manageduserOption {
	return func(m *ManagedUserMutation) {
		m.oldValue = func(context.Context) (*ManagedUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManagedUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManagedUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManagedUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManagedUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ManagedUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *ManagedUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ManagedUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ManagedUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[manageduser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ManagedUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[manageduser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ManagedUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, manageduser.FieldEmail)
}

// SetForcePasswordChange sets the "force_password_change" field.
func (m *ManagedUserMutation) SetForcePasswordChange(b bool) {
	m.force_password_change = &b
}

// ForcePasswordChange returns the value of the "force_password_change" field in the mutation.
func (m *ManagedUserMutation) ForcePasswordChange() (r bool, exists bool) {
	v := m.force_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldForcePasswordChange returns the old "force_password_change" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldForcePasswordChange(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForcePasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForcePasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForcePasswordChange: %w", err)
	}
	return oldValue.ForcePasswordChange, nil
}

// ResetForcePasswordChange resets all changes to the "force_password_change" field.
func (m *ManagedUserMutation) ResetForcePasswordChange() {
	m.force_password_change = nil
}

// SetFullname sets the "fullname" field.
func (m *ManagedUserMutation) SetFullname(s string) {
	m.fullname = &s
}

// Fullname returns the value of the "fullname" field in the mutation.
func (m *ManagedUserMutation) Fullname() (r string, exists bool) {
	v := m.fullname
	if v == nil {
		return
	}
	return *v, true
}

// OldFullname returns the old "fullname" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldFullname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullname: %w", err)
	}
	return oldValue.Fullname, nil
}

// ClearFullname clears the value of the "fullname" field.
func (m *ManagedUserMutation) ClearFullname() {
	m.fullname = nil
	m.clearedFields[manageduser.FieldFullname] = struct{}{}
}

// FullnameCleared returns if the "fullname" field was cleared in this mutation.
func (m *ManagedUserMutation) FullnameCleared() bool {
	_, ok := m.clearedFields[manageduser.FieldFullname]
	return ok
}

// ResetFullname resets all changes to the "fullname" field.
func (m *ManagedUserMutation) ResetFullname() {
	m.fullname = nil
	delete(m.clearedFields, manageduser.FieldFullname)
}

// SetLastPasswordChange sets the "last_password_change" field.
func (m *ManagedUserMutation) SetLastPasswordChange(t time.Time) {
	m.last_password_change = &t
}

// LastPasswordChange returns the value of the "last_password_change" field in the mutation.
func (m *ManagedUserMutation) LastPasswordChange() (r time.Time, exists bool) {
	v := m.last_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPasswordChange returns the old "last_password_change" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldLastPasswordChange(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPasswordChange: %w", err)
	}
	return oldValue.LastPasswordChange, nil
}

// ResetLastPasswordChange resets all changes to the "last_password_change" field.
func (m *ManagedUserMutation) ResetLastPasswordChange() {
	m.last_password_change = nil
}

// SetNonExpiryPassword sets the "non_expiry_password" field.
func (m *ManagedUserMutation) SetNonExpiryPassword(b bool) {
	m.non_expiry_password = &b
}

// NonExpiryPassword returns the value of the "non_expiry_password" field in the mutation.
func (m *ManagedUserMutation) NonExpiryPassword() (r bool, exists bool) {
	v := m.non_expiry_password
	if v == nil {
		return
	}
	return *v, true
}

// OldNonExpiryPassword returns the old "non_expiry_password" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldNonExpiryPassword(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonExpiryPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonExpiryPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonExpiryPassword: %w", err)
	}
	return oldValue.NonExpiryPassword, nil
}

// ResetNonExpiryPassword resets all changes to the "non_expiry_password" field.
func (m *ManagedUserMutation) ResetNonExpiryPassword() {
	m.non_expiry_password = nil
}

// SetPassword sets the "password" field.
func (m *ManagedUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ManagedUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ManagedUserMutation) ResetPassword() {
	m.password = nil
}

// SetSuspended sets the "suspended" field.
func (m *ManagedUserMutation) SetSuspended(b bool) {
	m.suspended = &b
}

// Suspended returns the value of the "suspended" field in the mutation.
func (m *ManagedUserMutation) Suspended() (r bool, exists bool) {
	v := m.suspended
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspended returns the old "suspended" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldSuspended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspended: %w", err)
	}
	return oldValue.Suspended, nil
}

// ResetSuspended resets all changes to the "suspended" field.
func (m *ManagedUserMutation) ResetSuspended() {
	m.suspended = nil
}

// SetUsername sets the "username" field.
func (m *ManagedUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ManagedUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ManagedUser entity.
// If the ManagedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagedUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ManagedUserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[manageduser.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ManagedUserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[manageduser.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ManagedUserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, manageduser.FieldUsername)
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *ManagedUserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *ManagedUserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *ManagedUserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *ManagedUserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *ManagedUserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *ManagedUserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *ManagedUserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *ManagedUserMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *ManagedUserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *ManagedUserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *ManagedUserMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *ManagedUserMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *ManagedUserMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *ManagedUserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the ManagedUserMutation builder.
func (m *ManagedUserMutation) Where(ps ...predicate.ManagedUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ManagedUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ManagedUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ManagedUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ManagedUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ManagedUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ManagedUser).
func (m *ManagedUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManagedUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, manageduser.FieldEmail)
	}
	if m.force_password_change != nil {
		fields = append(fields, manageduser.FieldForcePasswordChange)
	}
	if m.fullname != nil {
		fields = append(fields, manageduser.FieldFullname)
	}
	if m.last_password_change != nil {
		fields = append(fields, manageduser.FieldLastPasswordChange)
	}
	if m.non_expiry_password != nil {
		fields = append(fields, manageduser.FieldNonExpiryPassword)
	}
	if m.password != nil {
		fields = append(fields, manageduser.FieldPassword)
	}
	if m.suspended != nil {
		fields = append(fields, manageduser.FieldSuspended)
	}
	if m.username != nil {
		fields = append(fields, manageduser.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManagedUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manageduser.FieldEmail:
		return m.Email()
	case manageduser.FieldForcePasswordChange:
		return m.ForcePasswordChange()
	case manageduser.FieldFullname:
		return m.Fullname()
	case manageduser.FieldLastPasswordChange:
		return m.LastPasswordChange()
	case manageduser.FieldNonExpiryPassword:
		return m.NonExpiryPassword()
	case manageduser.FieldPassword:
		return m.Password()
	case manageduser.FieldSuspended:
		return m.Suspended()
	case manageduser.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManagedUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manageduser.FieldEmail:
		return m.OldEmail(ctx)
	case manageduser.FieldForcePasswordChange:
		return m.OldForcePasswordChange(ctx)
	case manageduser.FieldFullname:
		return m.OldFullname(ctx)
	case manageduser.FieldLastPasswordChange:
		return m.OldLastPasswordChange(ctx)
	case manageduser.FieldNonExpiryPassword:
		return m.OldNonExpiryPassword(ctx)
	case manageduser.FieldPassword:
		return m.OldPassword(ctx)
	case manageduser.FieldSuspended:
		return m.OldSuspended(ctx)
	case manageduser.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown ManagedUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagedUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manageduser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case manageduser.FieldForcePasswordChange:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForcePasswordChange(v)
		return nil
	case manageduser.FieldFullname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullname(v)
		return nil
	case manageduser.FieldLastPasswordChange:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPasswordChange(v)
		return nil
	case manageduser.FieldNonExpiryPassword:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonExpiryPassword(v)
		return nil
	case manageduser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case manageduser.FieldSuspended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspended(v)
		return nil
	case manageduser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown ManagedUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManagedUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManagedUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagedUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ManagedUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManagedUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(manageduser.FieldEmail) {
		fields = append(fields, manageduser.FieldEmail)
	}
	if m.FieldCleared(manageduser.FieldFullname) {
		fields = append(fields, manageduser.FieldFullname)
	}
	if m.FieldCleared(manageduser.FieldUsername) {
		fields = append(fields, manageduser.FieldUsername)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManagedUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManagedUserMutation) ClearField(name string) error {
	switch name {
	case manageduser.FieldEmail:
		m.ClearEmail()
		return nil
	case manageduser.FieldFullname:
		m.ClearFullname()
		return nil
	case manageduser.FieldUsername:
		m.ClearUsername()
		return nil
	}
	return fmt.Errorf("unknown ManagedUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManagedUserMutation) ResetField(name string) error {
	switch name {
	case manageduser.FieldEmail:
		m.ResetEmail()
		return nil
	case manageduser.FieldForcePasswordChange:
		m.ResetForcePasswordChange()
		return nil
	case manageduser.FieldFullname:
		m.ResetFullname()
		return nil
	case manageduser.FieldLastPasswordChange:
		m.ResetLastPasswordChange()
		return nil
	case manageduser.FieldNonExpiryPassword:
		m.ResetNonExpiryPassword()
		return nil
	case manageduser.FieldPassword:
		m.ResetPassword()
		return nil
	case manageduser.FieldSuspended:
		m.ResetSuspended()
		return nil
	case manageduser.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown ManagedUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManagedUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.permissions != nil {
		edges = append(edges, manageduser.EdgePermissions)
	}
	if m.teams != nil {
		edges = append(edges, manageduser.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManagedUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case manageduser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case manageduser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManagedUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpermissions != nil {
		edges = append(edges, manageduser.EdgePermissions)
	}
	if m.removedteams != nil {
		edges = append(edges, manageduser.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManagedUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case manageduser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case manageduser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManagedUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpermissions {
		edges = append(edges, manageduser.EdgePermissions)
	}
	if m.clearedteams {
		edges = append(edges, manageduser.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManagedUserMutation) EdgeCleared(name string) bool {
	switch name {
	case manageduser.EdgePermissions:
		return m.clearedpermissions
	case manageduser.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManagedUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ManagedUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManagedUserMutation) ResetEdge(name string) error {
	switch name {
	case manageduser.EdgePermissions:
		m.ResetPermissions()
		return nil
	case manageduser.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown ManagedUser edge %s", name)
}

// MappedLDAPGroupMutation represents an operation that mutates the MappedLDAPGroup nodes in the graph.
type MappedLDAPGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	dn            *string
	clearedFields map[string]struct{}
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*MappedLDAPGroup, error)
	predicates    []predicate.MappedLDAPGroup
}

var _ ent.Mutation = (*MappedLDAPGroupMutation)(nil)

// mappedldapgroupOption allows management of the mutation configuration using functional options.
type mappedldapgroupOption func(*MappedLDAPGroupMutation)

// newMappedLDAPGroupMutation creates new mutation for the MappedLDAPGroup entity.
func newMappedLDAPGroupMutation(c config, op Op, opts ...mappedldapgroupOption) *MappedLDAPGroupMutation {
	m := &MappedLDAPGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeMappedLDAPGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMappedLDAPGroupID sets the ID field of the mutation.
func withMappedLDAPGroupID(id int) mappedldapgroupOption {
	return func(m *MappedLDAPGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *MappedLDAPGroup
		)
		m.oldValue = func(ctx context.Context) (*MappedLDAPGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MappedLDAPGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMappedLDAPGroup sets the old MappedLDAPGroup of the mutation.
func withMappedLDAPGroup(node *MappedLDAPGroup) mappedldapgroupOption {
	return func(m *MappedLDAPGroupMutation) {
		m.oldValue = func(context.Context) (*MappedLDAPGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MappedLDAPGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MappedLDAPGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MappedLDAPGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MappedLDAPGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MappedLDAPGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *MappedLDAPGroupMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MappedLDAPGroupMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MappedLDAPGroup entity.
// If the MappedLDAPGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedLDAPGroupMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MappedLDAPGroupMutation) ResetUUID() {
	m.uuid = nil
}

// SetDn sets the "dn" field.
func (m *MappedLDAPGroupMutation) SetDn(s string) {
	m.dn = &s
}

// Dn returns the value of the "dn" field in the mutation.
func (m *MappedLDAPGroupMutation) Dn() (r string, exists bool) {
	v := m.dn
	if v == nil {
		return
	}
	return *v, true
}

// OldDn returns the old "dn" field's value of the MappedLDAPGroup entity.
// If the MappedLDAPGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedLDAPGroupMutation) OldDn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDn: %w", err)
	}
	return oldValue.Dn, nil
}

// ResetDn resets all changes to the "dn" field.
func (m *MappedLDAPGroupMutation) ResetDn() {
	m.dn = nil
}

// SetTeamID sets the "team_id" field.
func (m *MappedLDAPGroupMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *MappedLDAPGroupMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the MappedLDAPGroup entity.
// If the MappedLDAPGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedLDAPGroupMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *MappedLDAPGroupMutation) ClearTeamID() {
	m.team = nil
	m.clearedFields[mappedldapgroup.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *MappedLDAPGroupMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[mappedldapgroup.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *MappedLDAPGroupMutation) ResetTeamID() {
	m.team = nil
	delete(m.clearedFields, mappedldapgroup.FieldTeamID)
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *MappedLDAPGroupMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[mappedldapgroup.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *MappedLDAPGroupMutation) TeamCleared() bool {
	return m.TeamIDCleared() || m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *MappedLDAPGroupMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *MappedLDAPGroupMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the MappedLDAPGroupMutation builder.
func (m *MappedLDAPGroupMutation) Where(ps ...predicate.MappedLDAPGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MappedLDAPGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MappedLDAPGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MappedLDAPGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MappedLDAPGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MappedLDAPGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MappedLDAPGroup).
func (m *MappedLDAPGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MappedLDAPGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, mappedldapgroup.FieldUUID)
	}
	if m.dn != nil {
		fields = append(fields, mappedldapgroup.FieldDn)
	}
	if m.team != nil {
		fields = append(fields, mappedldapgroup.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MappedLDAPGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mappedldapgroup.FieldUUID:
		return m.UUID()
	case mappedldapgroup.FieldDn:
		return m.Dn()
	case mappedldapgroup.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MappedLDAPGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mappedldapgroup.FieldUUID:
		return m.OldUUID(ctx)
	case mappedldapgroup.FieldDn:
		return m.OldDn(ctx)
	case mappedldapgroup.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown MappedLDAPGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedLDAPGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mappedldapgroup.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case mappedldapgroup.FieldDn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDn(v)
		return nil
	case mappedldapgroup.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown MappedLDAPGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MappedLDAPGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MappedLDAPGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedLDAPGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MappedLDAPGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MappedLDAPGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mappedldapgroup.FieldTeamID) {
		fields = append(fields, mappedldapgroup.FieldTeamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MappedLDAPGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MappedLDAPGroupMutation) ClearField(name string) error {
	switch name {
	case mappedldapgroup.FieldTeamID:
		m.ClearTeamID()
		return nil
	}
	return fmt.Errorf("unknown MappedLDAPGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MappedLDAPGroupMutation) ResetField(name string) error {
	switch name {
	case mappedldapgroup.FieldUUID:
		m.ResetUUID()
		return nil
	case mappedldapgroup.FieldDn:
		m.ResetDn()
		return nil
	case mappedldapgroup.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown MappedLDAPGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MappedLDAPGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, mappedldapgroup.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MappedLDAPGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mappedldapgroup.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MappedLDAPGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MappedLDAPGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MappedLDAPGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, mappedldapgroup.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MappedLDAPGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case mappedldapgroup.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MappedLDAPGroupMutation) ClearEdge(name string) error {
	switch name {
	case mappedldapgroup.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown MappedLDAPGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MappedLDAPGroupMutation) ResetEdge(name string) error {
	switch name {
	case mappedldapgroup.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown MappedLDAPGroup edge %s", name)
}

// MappedOIDCGroupMutation represents an operation that mutates the MappedOIDCGroup nodes in the graph.
type MappedOIDCGroupMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *uuid.UUID
	clearedFields     map[string]struct{}
	oidc_group        *int
	clearedoidc_group bool
	team              *int
	clearedteam       bool
	done              bool
	oldValue          func(context.Context) (*MappedOIDCGroup, error)
	predicates        []predicate.MappedOIDCGroup
}

var _ ent.Mutation = (*MappedOIDCGroupMutation)(nil)

// mappedoidcgroupOption allows management of the mutation configuration using functional options.
type mappedoidcgroupOption func(*MappedOIDCGroupMutation)

// newMappedOIDCGroupMutation creates new mutation for the MappedOIDCGroup entity.
func newMappedOIDCGroupMutation(c config, op Op, opts ...mappedoidcgroupOption) *MappedOIDCGroupMutation {
	m := &MappedOIDCGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeMappedOIDCGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMappedOIDCGroupID sets the ID field of the mutation.
func withMappedOIDCGroupID(id int) mappedoidcgroupOption {
	return func(m *MappedOIDCGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *MappedOIDCGroup
		)
		m.oldValue = func(ctx context.Context) (*MappedOIDCGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MappedOIDCGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMappedOIDCGroup sets the old MappedOIDCGroup of the mutation.
func withMappedOIDCGroup(node *MappedOIDCGroup) mappedoidcgroupOption {
	return func(m *MappedOIDCGroupMutation) {
		m.oldValue = func(context.Context) (*MappedOIDCGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MappedOIDCGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MappedOIDCGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MappedOIDCGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MappedOIDCGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MappedOIDCGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *MappedOIDCGroupMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MappedOIDCGroupMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MappedOIDCGroup entity.
// If the MappedOIDCGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedOIDCGroupMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MappedOIDCGroupMutation) ResetUUID() {
	m.uuid = nil
}

// SetGroupID sets the "group_id" field.
func (m *MappedOIDCGroupMutation) SetGroupID(i int) {
	m.oidc_group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *MappedOIDCGroupMutation) GroupID() (r int, exists bool) {
	v := m.oidc_group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the MappedOIDCGroup entity.
// If the MappedOIDCGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedOIDCGroupMutation) OldGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *MappedOIDCGroupMutation) ClearGroupID() {
	m.oidc_group = nil
	m.clearedFields[mappedoidcgroup.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *MappedOIDCGroupMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[mappedoidcgroup.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *MappedOIDCGroupMutation) ResetGroupID() {
	m.oidc_group = nil
	delete(m.clearedFields, mappedoidcgroup.FieldGroupID)
}

// SetTeamID sets the "team_id" field.
func (m *MappedOIDCGroupMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *MappedOIDCGroupMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the MappedOIDCGroup entity.
// If the MappedOIDCGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedOIDCGroupMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *MappedOIDCGroupMutation) ClearTeamID() {
	m.team = nil
	m.clearedFields[mappedoidcgroup.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *MappedOIDCGroupMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[mappedoidcgroup.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *MappedOIDCGroupMutation) ResetTeamID() {
	m.team = nil
	delete(m.clearedFields, mappedoidcgroup.FieldTeamID)
}

// SetOidcGroupID sets the "oidc_group" edge to the OIDCGroup entity by id.
func (m *MappedOIDCGroupMutation) SetOidcGroupID(id int) {
	m.oidc_group = &id
}

// ClearOidcGroup clears the "oidc_group" edge to the OIDCGroup entity.
func (m *MappedOIDCGroupMutation) ClearOidcGroup() {
	m.clearedoidc_group = true
	m.clearedFields[mappedoidcgroup.FieldGroupID] = struct{}{}
}

// OidcGroupCleared reports if the "oidc_group" edge to the OIDCGroup entity was cleared.
func (m *MappedOIDCGroupMutation) OidcGroupCleared() bool {
	return m.GroupIDCleared() || m.clearedoidc_group
}

// OidcGroupID returns the "oidc_group" edge ID in the mutation.
func (m *MappedOIDCGroupMutation) OidcGroupID() (id int, exists bool) {
	if m.oidc_group != nil {
		return *m.oidc_group, true
	}
	return
}

// OidcGroupIDs returns the "oidc_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OidcGroupID instead. It exists only for internal usage by the builders.
func (m *MappedOIDCGroupMutation) OidcGroupIDs() (ids []int) {
	if id := m.oidc_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOidcGroup resets all changes to the "oidc_group" edge.
func (m *MappedOIDCGroupMutation) ResetOidcGroup() {
	m.oidc_group = nil
	m.clearedoidc_group = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *MappedOIDCGroupMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[mappedoidcgroup.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *MappedOIDCGroupMutation) TeamCleared() bool {
	return m.TeamIDCleared() || m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *MappedOIDCGroupMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *MappedOIDCGroupMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the MappedOIDCGroupMutation builder.
func (m *MappedOIDCGroupMutation) Where(ps ...predicate.MappedOIDCGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MappedOIDCGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MappedOIDCGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MappedOIDCGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MappedOIDCGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MappedOIDCGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MappedOIDCGroup).
func (m *MappedOIDCGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MappedOIDCGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, mappedoidcgroup.FieldUUID)
	}
	if m.oidc_group != nil {
		fields = append(fields, mappedoidcgroup.FieldGroupID)
	}
	if m.team != nil {
		fields = append(fields, mappedoidcgroup.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MappedOIDCGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mappedoidcgroup.FieldUUID:
		return m.UUID()
	case mappedoidcgroup.FieldGroupID:
		return m.GroupID()
	case mappedoidcgroup.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MappedOIDCGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mappedoidcgroup.FieldUUID:
		return m.OldUUID(ctx)
	case mappedoidcgroup.FieldGroupID:
		return m.OldGroupID(ctx)
	case mappedoidcgroup.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown MappedOIDCGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedOIDCGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mappedoidcgroup.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case mappedoidcgroup.FieldGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case mappedoidcgroup.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown MappedOIDCGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MappedOIDCGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MappedOIDCGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedOIDCGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MappedOIDCGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MappedOIDCGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mappedoidcgroup.FieldGroupID) {
		fields = append(fields, mappedoidcgroup.FieldGroupID)
	}
	if m.FieldCleared(mappedoidcgroup.FieldTeamID) {
		fields = append(fields, mappedoidcgroup.FieldTeamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MappedOIDCGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MappedOIDCGroupMutation) ClearField(name string) error {
	switch name {
	case mappedoidcgroup.FieldGroupID:
		m.ClearGroupID()
		return nil
	case mappedoidcgroup.FieldTeamID:
		m.ClearTeamID()
		return nil
	}
	return fmt.Errorf("unknown MappedOIDCGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MappedOIDCGroupMutation) ResetField(name string) error {
	switch name {
	case mappedoidcgroup.FieldUUID:
		m.ResetUUID()
		return nil
	case mappedoidcgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case mappedoidcgroup.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown MappedOIDCGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MappedOIDCGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.oidc_group != nil {
		edges = append(edges, mappedoidcgroup.EdgeOidcGroup)
	}
	if m.team != nil {
		edges = append(edges, mappedoidcgroup.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MappedOIDCGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mappedoidcgroup.EdgeOidcGroup:
		if id := m.oidc_group; id != nil {
			return []ent.Value{*id}
		}
	case mappedoidcgroup.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MappedOIDCGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MappedOIDCGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MappedOIDCGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoidc_group {
		edges = append(edges, mappedoidcgroup.EdgeOidcGroup)
	}
	if m.clearedteam {
		edges = append(edges, mappedoidcgroup.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MappedOIDCGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case mappedoidcgroup.EdgeOidcGroup:
		return m.clearedoidc_group
	case mappedoidcgroup.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MappedOIDCGroupMutation) ClearEdge(name string) error {
	switch name {
	case mappedoidcgroup.EdgeOidcGroup:
		m.ClearOidcGroup()
		return nil
	case mappedoidcgroup.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown MappedOIDCGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MappedOIDCGroupMutation) ResetEdge(name string) error {
	switch name {
	case mappedoidcgroup.EdgeOidcGroup:
		m.ResetOidcGroup()
		return nil
	case mappedoidcgroup.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown MappedOIDCGroup edge %s", name)
}

// OIDCGroupMutation represents an operation that mutates the OIDCGroup nodes in the graph.
type OIDCGroupMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	uuid                      *uuid.UUID
	name                      *string
	clearedFields             map[string]struct{}
	mapped_oidc_groups        map[int]struct{}
	removedmapped_oidc_groups map[int]struct{}
	clearedmapped_oidc_groups bool
	team                      map[int]struct{}
	removedteam               map[int]struct{}
	clearedteam               bool
	done                      bool
	oldValue                  func(context.Context) (*OIDCGroup, error)
	predicates                []predicate.OIDCGroup
}

var _ ent.Mutation = (*OIDCGroupMutation)(nil)

// oidcgroupOption allows management of the mutation configuration using functional options.
type oidcgroupOption func(*OIDCGroupMutation)

// newOIDCGroupMutation creates new mutation for the OIDCGroup entity.
func newOIDCGroupMutation(c config, op Op, opts ...oidcgroupOption) *OIDCGroupMutation {
	m := &OIDCGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeOIDCGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOIDCGroupID sets the ID field of the mutation.
func withOIDCGroupID(id int) oidcgroupOption {
	return func(m *OIDCGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *OIDCGroup
		)
		m.oldValue = func(ctx context.Context) (*OIDCGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OIDCGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOIDCGroup sets the old OIDCGroup of the mutation.
func withOIDCGroup(node *OIDCGroup) oidcgroupOption {
	return func(m *OIDCGroupMutation) {
		m.oldValue = func(context.Context) (*OIDCGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OIDCGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OIDCGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OIDCGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OIDCGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OIDCGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *OIDCGroupMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *OIDCGroupMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the OIDCGroup entity.
// If the OIDCGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCGroupMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *OIDCGroupMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *OIDCGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OIDCGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OIDCGroup entity.
// If the OIDCGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OIDCGroupMutation) ResetName() {
	m.name = nil
}

// AddMappedOidcGroupIDs adds the "mapped_oidc_groups" edge to the MappedOIDCGroup entity by ids.
func (m *OIDCGroupMutation) AddMappedOidcGroupIDs(ids ...int) {
	if m.mapped_oidc_groups == nil {
		m.mapped_oidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.mapped_oidc_groups[ids[i]] = struct{}{}
	}
}

// ClearMappedOidcGroups clears the "mapped_oidc_groups" edge to the MappedOIDCGroup entity.
func (m *OIDCGroupMutation) ClearMappedOidcGroups() {
	m.clearedmapped_oidc_groups = true
}

// MappedOidcGroupsCleared reports if the "mapped_oidc_groups" edge to the MappedOIDCGroup entity was cleared.
func (m *OIDCGroupMutation) MappedOidcGroupsCleared() bool {
	return m.clearedmapped_oidc_groups
}

// RemoveMappedOidcGroupIDs removes the "mapped_oidc_groups" edge to the MappedOIDCGroup entity by IDs.
func (m *OIDCGroupMutation) RemoveMappedOidcGroupIDs(ids ...int) {
	if m.removedmapped_oidc_groups == nil {
		m.removedmapped_oidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mapped_oidc_groups, ids[i])
		m.removedmapped_oidc_groups[ids[i]] = struct{}{}
	}
}

// RemovedMappedOidcGroups returns the removed IDs of the "mapped_oidc_groups" edge to the MappedOIDCGroup entity.
func (m *OIDCGroupMutation) RemovedMappedOidcGroupsIDs() (ids []int) {
	for id := range m.removedmapped_oidc_groups {
		ids = append(ids, id)
	}
	return
}

// MappedOidcGroupsIDs returns the "mapped_oidc_groups" edge IDs in the mutation.
func (m *OIDCGroupMutation) MappedOidcGroupsIDs() (ids []int) {
	for id := range m.mapped_oidc_groups {
		ids = append(ids, id)
	}
	return
}

// ResetMappedOidcGroups resets all changes to the "mapped_oidc_groups" edge.
func (m *OIDCGroupMutation) ResetMappedOidcGroups() {
	m.mapped_oidc_groups = nil
	m.clearedmapped_oidc_groups = false
	m.removedmapped_oidc_groups = nil
}

// AddTeamIDs adds the "team" edge to the Team entity by ids.
func (m *OIDCGroupMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *OIDCGroupMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *OIDCGroupMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the "team" edge to the Team entity by IDs.
func (m *OIDCGroupMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.team, ids[i])
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed IDs of the "team" edge to the Team entity.
func (m *OIDCGroupMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
func (m *OIDCGroupMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *OIDCGroupMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// Where appends a list predicates to the OIDCGroupMutation builder.
func (m *OIDCGroupMutation) Where(ps ...predicate.OIDCGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OIDCGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OIDCGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OIDCGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OIDCGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OIDCGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OIDCGroup).
func (m *OIDCGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OIDCGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.uuid != nil {
		fields = append(fields, oidcgroup.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, oidcgroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OIDCGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oidcgroup.FieldUUID:
		return m.UUID()
	case oidcgroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OIDCGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oidcgroup.FieldUUID:
		return m.OldUUID(ctx)
	case oidcgroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown OIDCGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oidcgroup.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case oidcgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown OIDCGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OIDCGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OIDCGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OIDCGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OIDCGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OIDCGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OIDCGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OIDCGroupMutation) ResetField(name string) error {
	switch name {
	case oidcgroup.FieldUUID:
		m.ResetUUID()
		return nil
	case oidcgroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown OIDCGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OIDCGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mapped_oidc_groups != nil {
		edges = append(edges, oidcgroup.EdgeMappedOidcGroups)
	}
	if m.team != nil {
		edges = append(edges, oidcgroup.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OIDCGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oidcgroup.EdgeMappedOidcGroups:
		ids := make([]ent.Value, 0, len(m.mapped_oidc_groups))
		for id := range m.mapped_oidc_groups {
			ids = append(ids, id)
		}
		return ids
	case oidcgroup.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OIDCGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmapped_oidc_groups != nil {
		edges = append(edges, oidcgroup.EdgeMappedOidcGroups)
	}
	if m.removedteam != nil {
		edges = append(edges, oidcgroup.EdgeTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OIDCGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oidcgroup.EdgeMappedOidcGroups:
		ids := make([]ent.Value, 0, len(m.removedmapped_oidc_groups))
		for id := range m.removedmapped_oidc_groups {
			ids = append(ids, id)
		}
		return ids
	case oidcgroup.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OIDCGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmapped_oidc_groups {
		edges = append(edges, oidcgroup.EdgeMappedOidcGroups)
	}
	if m.clearedteam {
		edges = append(edges, oidcgroup.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OIDCGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case oidcgroup.EdgeMappedOidcGroups:
		return m.clearedmapped_oidc_groups
	case oidcgroup.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OIDCGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OIDCGroupMutation) ResetEdge(name string) error {
	switch name {
	case oidcgroup.EdgeMappedOidcGroups:
		m.ResetMappedOidcGroups()
		return nil
	case oidcgroup.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown OIDCGroup edge %s", name)
}

// OIDCUserMutation represents an operation that mutates the OIDCUser nodes in the graph.
type OIDCUserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	email              *string
	subject_identifier *string
	username           *string
	clearedFields      map[string]struct{}
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	teams              map[int]struct{}
	removedteams       map[int]struct{}
	clearedteams       bool
	done               bool
	oldValue           func(context.Context) (*OIDCUser, error)
	predicates         []predicate.OIDCUser
}

var _ ent.Mutation = (*OIDCUserMutation)(nil)

// oidcuserOption allows management of the mutation configuration using functional options.
type oidcuserOption func(*OIDCUserMutation)

// newOIDCUserMutation creates new mutation for the OIDCUser entity.
func newOIDCUserMutation(c config, op Op, opts ...oidcuserOption) *OIDCUserMutation {
	m := &OIDCUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOIDCUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOIDCUserID sets the ID field of the mutation.
func withOIDCUserID(id int) oidcuserOption {
	return func(m *OIDCUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OIDCUser
		)
		m.oldValue = func(ctx context.Context) (*OIDCUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OIDCUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOIDCUser sets the old OIDCUser of the mutation.
func withOIDCUser(node *OIDCUser) oidcuserOption {
	return func(m *OIDCUserMutation) {
		m.oldValue = func(context.Context) (*OIDCUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OIDCUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OIDCUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OIDCUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OIDCUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OIDCUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *OIDCUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *OIDCUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the OIDCUser entity.
// If the OIDCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *OIDCUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[oidcuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *OIDCUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[oidcuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *OIDCUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, oidcuser.FieldEmail)
}

// SetSubjectIdentifier sets the "subject_identifier" field.
func (m *OIDCUserMutation) SetSubjectIdentifier(s string) {
	m.subject_identifier = &s
}

// SubjectIdentifier returns the value of the "subject_identifier" field in the mutation.
func (m *OIDCUserMutation) SubjectIdentifier() (r string, exists bool) {
	v := m.subject_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectIdentifier returns the old "subject_identifier" field's value of the OIDCUser entity.
// If the OIDCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCUserMutation) OldSubjectIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectIdentifier: %w", err)
	}
	return oldValue.SubjectIdentifier, nil
}

// ClearSubjectIdentifier clears the value of the "subject_identifier" field.
func (m *OIDCUserMutation) ClearSubjectIdentifier() {
	m.subject_identifier = nil
	m.clearedFields[oidcuser.FieldSubjectIdentifier] = struct{}{}
}

// SubjectIdentifierCleared returns if the "subject_identifier" field was cleared in this mutation.
func (m *OIDCUserMutation) SubjectIdentifierCleared() bool {
	_, ok := m.clearedFields[oidcuser.FieldSubjectIdentifier]
	return ok
}

// ResetSubjectIdentifier resets all changes to the "subject_identifier" field.
func (m *OIDCUserMutation) ResetSubjectIdentifier() {
	m.subject_identifier = nil
	delete(m.clearedFields, oidcuser.FieldSubjectIdentifier)
}

// SetUsername sets the "username" field.
func (m *OIDCUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OIDCUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OIDCUser entity.
// If the OIDCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OIDCUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OIDCUserMutation) ResetUsername() {
	m.username = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *OIDCUserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *OIDCUserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *OIDCUserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *OIDCUserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *OIDCUserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *OIDCUserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *OIDCUserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *OIDCUserMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *OIDCUserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *OIDCUserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *OIDCUserMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *OIDCUserMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *OIDCUserMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *OIDCUserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the OIDCUserMutation builder.
func (m *OIDCUserMutation) Where(ps ...predicate.OIDCUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OIDCUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OIDCUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OIDCUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OIDCUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OIDCUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OIDCUser).
func (m *OIDCUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OIDCUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, oidcuser.FieldEmail)
	}
	if m.subject_identifier != nil {
		fields = append(fields, oidcuser.FieldSubjectIdentifier)
	}
	if m.username != nil {
		fields = append(fields, oidcuser.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OIDCUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oidcuser.FieldEmail:
		return m.Email()
	case oidcuser.FieldSubjectIdentifier:
		return m.SubjectIdentifier()
	case oidcuser.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OIDCUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oidcuser.FieldEmail:
		return m.OldEmail(ctx)
	case oidcuser.FieldSubjectIdentifier:
		return m.OldSubjectIdentifier(ctx)
	case oidcuser.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown OIDCUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oidcuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case oidcuser.FieldSubjectIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectIdentifier(v)
		return nil
	case oidcuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown OIDCUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OIDCUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OIDCUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OIDCUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OIDCUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oidcuser.FieldEmail) {
		fields = append(fields, oidcuser.FieldEmail)
	}
	if m.FieldCleared(oidcuser.FieldSubjectIdentifier) {
		fields = append(fields, oidcuser.FieldSubjectIdentifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OIDCUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OIDCUserMutation) ClearField(name string) error {
	switch name {
	case oidcuser.FieldEmail:
		m.ClearEmail()
		return nil
	case oidcuser.FieldSubjectIdentifier:
		m.ClearSubjectIdentifier()
		return nil
	}
	return fmt.Errorf("unknown OIDCUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OIDCUserMutation) ResetField(name string) error {
	switch name {
	case oidcuser.FieldEmail:
		m.ResetEmail()
		return nil
	case oidcuser.FieldSubjectIdentifier:
		m.ResetSubjectIdentifier()
		return nil
	case oidcuser.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown OIDCUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OIDCUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.permissions != nil {
		edges = append(edges, oidcuser.EdgePermissions)
	}
	if m.teams != nil {
		edges = append(edges, oidcuser.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OIDCUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oidcuser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case oidcuser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OIDCUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpermissions != nil {
		edges = append(edges, oidcuser.EdgePermissions)
	}
	if m.removedteams != nil {
		edges = append(edges, oidcuser.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OIDCUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oidcuser.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case oidcuser.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OIDCUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpermissions {
		edges = append(edges, oidcuser.EdgePermissions)
	}
	if m.clearedteams {
		edges = append(edges, oidcuser.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OIDCUserMutation) EdgeCleared(name string) bool {
	switch name {
	case oidcuser.EdgePermissions:
		return m.clearedpermissions
	case oidcuser.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OIDCUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OIDCUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OIDCUserMutation) ResetEdge(name string) error {
	switch name {
	case oidcuser.EdgePermissions:
		m.ResetPermissions()
		return nil
	case oidcuser.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown OIDCUser edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	description          *string
	name                 *string
	clearedFields        map[string]struct{}
	teams                map[int]struct{}
	removedteams         map[int]struct{}
	clearedteams         bool
	ldap_users           map[int]struct{}
	removedldap_users    map[int]struct{}
	clearedldap_users    bool
	managed_users        map[int]struct{}
	removedmanaged_users map[int]struct{}
	clearedmanaged_users bool
	oidc_users           map[int]struct{}
	removedoidc_users    map[int]struct{}
	clearedoidc_users    bool
	done                 bool
	oldValue             func(context.Context) (*Permission, error)
	predicates           []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *PermissionMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *PermissionMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *PermissionMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *PermissionMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *PermissionMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *PermissionMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *PermissionMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddLdapUserIDs adds the "ldap_users" edge to the LDAPUser entity by ids.
func (m *PermissionMutation) AddLdapUserIDs(ids ...int) {
	if m.ldap_users == nil {
		m.ldap_users = make(map[int]struct{})
	}
	for i := range ids {
		m.ldap_users[ids[i]] = struct{}{}
	}
}

// ClearLdapUsers clears the "ldap_users" edge to the LDAPUser entity.
func (m *PermissionMutation) ClearLdapUsers() {
	m.clearedldap_users = true
}

// LdapUsersCleared reports if the "ldap_users" edge to the LDAPUser entity was cleared.
func (m *PermissionMutation) LdapUsersCleared() bool {
	return m.clearedldap_users
}

// RemoveLdapUserIDs removes the "ldap_users" edge to the LDAPUser entity by IDs.
func (m *PermissionMutation) RemoveLdapUserIDs(ids ...int) {
	if m.removedldap_users == nil {
		m.removedldap_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ldap_users, ids[i])
		m.removedldap_users[ids[i]] = struct{}{}
	}
}

// RemovedLdapUsers returns the removed IDs of the "ldap_users" edge to the LDAPUser entity.
func (m *PermissionMutation) RemovedLdapUsersIDs() (ids []int) {
	for id := range m.removedldap_users {
		ids = append(ids, id)
	}
	return
}

// LdapUsersIDs returns the "ldap_users" edge IDs in the mutation.
func (m *PermissionMutation) LdapUsersIDs() (ids []int) {
	for id := range m.ldap_users {
		ids = append(ids, id)
	}
	return
}

// ResetLdapUsers resets all changes to the "ldap_users" edge.
func (m *PermissionMutation) ResetLdapUsers() {
	m.ldap_users = nil
	m.clearedldap_users = false
	m.removedldap_users = nil
}

// AddManagedUserIDs adds the "managed_users" edge to the ManagedUser entity by ids.
func (m *PermissionMutation) AddManagedUserIDs(ids ...int) {
	if m.managed_users == nil {
		m.managed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.managed_users[ids[i]] = struct{}{}
	}
}

// ClearManagedUsers clears the "managed_users" edge to the ManagedUser entity.
func (m *PermissionMutation) ClearManagedUsers() {
	m.clearedmanaged_users = true
}

// ManagedUsersCleared reports if the "managed_users" edge to the ManagedUser entity was cleared.
func (m *PermissionMutation) ManagedUsersCleared() bool {
	return m.clearedmanaged_users
}

// RemoveManagedUserIDs removes the "managed_users" edge to the ManagedUser entity by IDs.
func (m *PermissionMutation) RemoveManagedUserIDs(ids ...int) {
	if m.removedmanaged_users == nil {
		m.removedmanaged_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.managed_users, ids[i])
		m.removedmanaged_users[ids[i]] = struct{}{}
	}
}

// RemovedManagedUsers returns the removed IDs of the "managed_users" edge to the ManagedUser entity.
func (m *PermissionMutation) RemovedManagedUsersIDs() (ids []int) {
	for id := range m.removedmanaged_users {
		ids = append(ids, id)
	}
	return
}

// ManagedUsersIDs returns the "managed_users" edge IDs in the mutation.
func (m *PermissionMutation) ManagedUsersIDs() (ids []int) {
	for id := range m.managed_users {
		ids = append(ids, id)
	}
	return
}

// ResetManagedUsers resets all changes to the "managed_users" edge.
func (m *PermissionMutation) ResetManagedUsers() {
	m.managed_users = nil
	m.clearedmanaged_users = false
	m.removedmanaged_users = nil
}

// AddOidcUserIDs adds the "oidc_users" edge to the OIDCUser entity by ids.
func (m *PermissionMutation) AddOidcUserIDs(ids ...int) {
	if m.oidc_users == nil {
		m.oidc_users = make(map[int]struct{})
	}
	for i := range ids {
		m.oidc_users[ids[i]] = struct{}{}
	}
}

// ClearOidcUsers clears the "oidc_users" edge to the OIDCUser entity.
func (m *PermissionMutation) ClearOidcUsers() {
	m.clearedoidc_users = true
}

// OidcUsersCleared reports if the "oidc_users" edge to the OIDCUser entity was cleared.
func (m *PermissionMutation) OidcUsersCleared() bool {
	return m.clearedoidc_users
}

// RemoveOidcUserIDs removes the "oidc_users" edge to the OIDCUser entity by IDs.
func (m *PermissionMutation) RemoveOidcUserIDs(ids ...int) {
	if m.removedoidc_users == nil {
		m.removedoidc_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.oidc_users, ids[i])
		m.removedoidc_users[ids[i]] = struct{}{}
	}
}

// RemovedOidcUsers returns the removed IDs of the "oidc_users" edge to the OIDCUser entity.
func (m *PermissionMutation) RemovedOidcUsersIDs() (ids []int) {
	for id := range m.removedoidc_users {
		ids = append(ids, id)
	}
	return
}

// OidcUsersIDs returns the "oidc_users" edge IDs in the mutation.
func (m *PermissionMutation) OidcUsersIDs() (ids []int) {
	for id := range m.oidc_users {
		ids = append(ids, id)
	}
	return
}

// ResetOidcUsers resets all changes to the "oidc_users" edge.
func (m *PermissionMutation) ResetOidcUsers() {
	m.oidc_users = nil
	m.clearedoidc_users = false
	m.removedoidc_users = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teams != nil {
		edges = append(edges, permission.EdgeTeams)
	}
	if m.ldap_users != nil {
		edges = append(edges, permission.EdgeLdapUsers)
	}
	if m.managed_users != nil {
		edges = append(edges, permission.EdgeManagedUsers)
	}
	if m.oidc_users != nil {
		edges = append(edges, permission.EdgeOidcUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeLdapUsers:
		ids := make([]ent.Value, 0, len(m.ldap_users))
		for id := range m.ldap_users {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeManagedUsers:
		ids := make([]ent.Value, 0, len(m.managed_users))
		for id := range m.managed_users {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeOidcUsers:
		ids := make([]ent.Value, 0, len(m.oidc_users))
		for id := range m.oidc_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedteams != nil {
		edges = append(edges, permission.EdgeTeams)
	}
	if m.removedldap_users != nil {
		edges = append(edges, permission.EdgeLdapUsers)
	}
	if m.removedmanaged_users != nil {
		edges = append(edges, permission.EdgeManagedUsers)
	}
	if m.removedoidc_users != nil {
		edges = append(edges, permission.EdgeOidcUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeLdapUsers:
		ids := make([]ent.Value, 0, len(m.removedldap_users))
		for id := range m.removedldap_users {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeManagedUsers:
		ids := make([]ent.Value, 0, len(m.removedmanaged_users))
		for id := range m.removedmanaged_users {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeOidcUsers:
		ids := make([]ent.Value, 0, len(m.removedoidc_users))
		for id := range m.removedoidc_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteams {
		edges = append(edges, permission.EdgeTeams)
	}
	if m.clearedldap_users {
		edges = append(edges, permission.EdgeLdapUsers)
	}
	if m.clearedmanaged_users {
		edges = append(edges, permission.EdgeManagedUsers)
	}
	if m.clearedoidc_users {
		edges = append(edges, permission.EdgeOidcUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeTeams:
		return m.clearedteams
	case permission.EdgeLdapUsers:
		return m.clearedldap_users
	case permission.EdgeManagedUsers:
		return m.clearedmanaged_users
	case permission.EdgeOidcUsers:
		return m.clearedoidc_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeTeams:
		m.ResetTeams()
		return nil
	case permission.EdgeLdapUsers:
		m.ResetLdapUsers()
		return nil
	case permission.EdgeManagedUsers:
		m.ResetManagedUsers()
		return nil
	case permission.EdgeOidcUsers:
		m.ResetOidcUsers()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// SchemaVersionMutation represents an operation that mutates the SchemaVersion nodes in the graph.
type SchemaVersionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	version       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SchemaVersion, error)
	predicates    []predicate.SchemaVersion
}

var _ ent.Mutation = (*SchemaVersionMutation)(nil)

// schemaversionOption allows management of the mutation configuration using functional options.
type schemaversionOption func(*SchemaVersionMutation)

// newSchemaVersionMutation creates new mutation for the SchemaVersion entity.
func newSchemaVersionMutation(c config, op Op, opts ...schemaversionOption) *SchemaVersionMutation {
	m := &SchemaVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaVersionID sets the ID field of the mutation.
func withSchemaVersionID(id int) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaVersion
		)
		m.oldValue = func(ctx context.Context) (*SchemaVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaVersion sets the old SchemaVersion of the mutation.
func withSchemaVersion(node *SchemaVersion) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		m.oldValue = func(context.Context) (*SchemaVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SchemaVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *SchemaVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *SchemaVersionMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[schemaversion.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *SchemaVersionMutation) VersionCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *SchemaVersionMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, schemaversion.FieldVersion)
}

// Where appends a list predicates to the SchemaVersionMutation builder.
func (m *SchemaVersionMutation) Where(ps ...predicate.SchemaVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaVersion).
func (m *SchemaVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaVersionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.version != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemaversion.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemaVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schemaversion.FieldVersion) {
		fields = append(fields, schemaversion.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ClearField(name string) error {
	switch name {
	case schemaversion.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ResetField(name string) error {
	switch name {
	case schemaversion.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	uuid                      *uuid.UUID
	name                      *string
	clearedFields             map[string]struct{}
	api_keys                  map[int]struct{}
	removedapi_keys           map[int]struct{}
	clearedapi_keys           bool
	permissions               map[int]struct{}
	removedpermissions        map[int]struct{}
	clearedpermissions        bool
	oidc_groups               map[int]struct{}
	removedoidc_groups        map[int]struct{}
	clearedoidc_groups        bool
	mapped_ldap_groups        map[int]struct{}
	removedmapped_ldap_groups map[int]struct{}
	clearedmapped_ldap_groups bool
	mapped_oidc_groups        map[int]struct{}
	removedmapped_oidc_groups map[int]struct{}
	clearedmapped_oidc_groups bool
	ldap_users                map[int]struct{}
	removedldap_users         map[int]struct{}
	clearedldap_users         bool
	managed_users             map[int]struct{}
	removedmanaged_users      map[int]struct{}
	clearedmanaged_users      bool
	oidc_users                map[int]struct{}
	removedoidc_users         map[int]struct{}
	clearedoidc_users         bool
	done                      bool
	oldValue                  func(context.Context) (*Team, error)
	predicates                []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *TeamMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TeamMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TeamMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *TeamMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *TeamMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *TeamMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *TeamMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *TeamMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *TeamMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *TeamMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *TeamMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *TeamMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *TeamMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *TeamMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *TeamMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *TeamMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *TeamMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddOidcGroupIDs adds the "oidc_groups" edge to the OIDCGroup entity by ids.
func (m *TeamMutation) AddOidcGroupIDs(ids ...int) {
	if m.oidc_groups == nil {
		m.oidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.oidc_groups[ids[i]] = struct{}{}
	}
}

// ClearOidcGroups clears the "oidc_groups" edge to the OIDCGroup entity.
func (m *TeamMutation) ClearOidcGroups() {
	m.clearedoidc_groups = true
}

// OidcGroupsCleared reports if the "oidc_groups" edge to the OIDCGroup entity was cleared.
func (m *TeamMutation) OidcGroupsCleared() bool {
	return m.clearedoidc_groups
}

// RemoveOidcGroupIDs removes the "oidc_groups" edge to the OIDCGroup entity by IDs.
func (m *TeamMutation) RemoveOidcGroupIDs(ids ...int) {
	if m.removedoidc_groups == nil {
		m.removedoidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.oidc_groups, ids[i])
		m.removedoidc_groups[ids[i]] = struct{}{}
	}
}

// RemovedOidcGroups returns the removed IDs of the "oidc_groups" edge to the OIDCGroup entity.
func (m *TeamMutation) RemovedOidcGroupsIDs() (ids []int) {
	for id := range m.removedoidc_groups {
		ids = append(ids, id)
	}
	return
}

// OidcGroupsIDs returns the "oidc_groups" edge IDs in the mutation.
func (m *TeamMutation) OidcGroupsIDs() (ids []int) {
	for id := range m.oidc_groups {
		ids = append(ids, id)
	}
	return
}

// ResetOidcGroups resets all changes to the "oidc_groups" edge.
func (m *TeamMutation) ResetOidcGroups() {
	m.oidc_groups = nil
	m.clearedoidc_groups = false
	m.removedoidc_groups = nil
}

// AddMappedLdapGroupIDs adds the "mapped_ldap_groups" edge to the MappedLDAPGroup entity by ids.
func (m *TeamMutation) AddMappedLdapGroupIDs(ids ...int) {
	if m.mapped_ldap_groups == nil {
		m.mapped_ldap_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.mapped_ldap_groups[ids[i]] = struct{}{}
	}
}

// ClearMappedLdapGroups clears the "mapped_ldap_groups" edge to the MappedLDAPGroup entity.
func (m *TeamMutation) ClearMappedLdapGroups() {
	m.clearedmapped_ldap_groups = true
}

// MappedLdapGroupsCleared reports if the "mapped_ldap_groups" edge to the MappedLDAPGroup entity was cleared.
func (m *TeamMutation) MappedLdapGroupsCleared() bool {
	return m.clearedmapped_ldap_groups
}

// RemoveMappedLdapGroupIDs removes the "mapped_ldap_groups" edge to the MappedLDAPGroup entity by IDs.
func (m *TeamMutation) RemoveMappedLdapGroupIDs(ids ...int) {
	if m.removedmapped_ldap_groups == nil {
		m.removedmapped_ldap_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mapped_ldap_groups, ids[i])
		m.removedmapped_ldap_groups[ids[i]] = struct{}{}
	}
}

// RemovedMappedLdapGroups returns the removed IDs of the "mapped_ldap_groups" edge to the MappedLDAPGroup entity.
func (m *TeamMutation) RemovedMappedLdapGroupsIDs() (ids []int) {
	for id := range m.removedmapped_ldap_groups {
		ids = append(ids, id)
	}
	return
}

// MappedLdapGroupsIDs returns the "mapped_ldap_groups" edge IDs in the mutation.
func (m *TeamMutation) MappedLdapGroupsIDs() (ids []int) {
	for id := range m.mapped_ldap_groups {
		ids = append(ids, id)
	}
	return
}

// ResetMappedLdapGroups resets all changes to the "mapped_ldap_groups" edge.
func (m *TeamMutation) ResetMappedLdapGroups() {
	m.mapped_ldap_groups = nil
	m.clearedmapped_ldap_groups = false
	m.removedmapped_ldap_groups = nil
}

// AddMappedOidcGroupIDs adds the "mapped_oidc_groups" edge to the MappedOIDCGroup entity by ids.
func (m *TeamMutation) AddMappedOidcGroupIDs(ids ...int) {
	if m.mapped_oidc_groups == nil {
		m.mapped_oidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.mapped_oidc_groups[ids[i]] = struct{}{}
	}
}

// ClearMappedOidcGroups clears the "mapped_oidc_groups" edge to the MappedOIDCGroup entity.
func (m *TeamMutation) ClearMappedOidcGroups() {
	m.clearedmapped_oidc_groups = true
}

// MappedOidcGroupsCleared reports if the "mapped_oidc_groups" edge to the MappedOIDCGroup entity was cleared.
func (m *TeamMutation) MappedOidcGroupsCleared() bool {
	return m.clearedmapped_oidc_groups
}

// RemoveMappedOidcGroupIDs removes the "mapped_oidc_groups" edge to the MappedOIDCGroup entity by IDs.
func (m *TeamMutation) RemoveMappedOidcGroupIDs(ids ...int) {
	if m.removedmapped_oidc_groups == nil {
		m.removedmapped_oidc_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mapped_oidc_groups, ids[i])
		m.removedmapped_oidc_groups[ids[i]] = struct{}{}
	}
}

// RemovedMappedOidcGroups returns the removed IDs of the "mapped_oidc_groups" edge to the MappedOIDCGroup entity.
func (m *TeamMutation) RemovedMappedOidcGroupsIDs() (ids []int) {
	for id := range m.removedmapped_oidc_groups {
		ids = append(ids, id)
	}
	return
}

// MappedOidcGroupsIDs returns the "mapped_oidc_groups" edge IDs in the mutation.
func (m *TeamMutation) MappedOidcGroupsIDs() (ids []int) {
	for id := range m.mapped_oidc_groups {
		ids = append(ids, id)
	}
	return
}

// ResetMappedOidcGroups resets all changes to the "mapped_oidc_groups" edge.
func (m *TeamMutation) ResetMappedOidcGroups() {
	m.mapped_oidc_groups = nil
	m.clearedmapped_oidc_groups = false
	m.removedmapped_oidc_groups = nil
}

// AddLdapUserIDs adds the "ldap_users" edge to the LDAPUser entity by ids.
func (m *TeamMutation) AddLdapUserIDs(ids ...int) {
	if m.ldap_users == nil {
		m.ldap_users = make(map[int]struct{})
	}
	for i := range ids {
		m.ldap_users[ids[i]] = struct{}{}
	}
}

// ClearLdapUsers clears the "ldap_users" edge to the LDAPUser entity.
func (m *TeamMutation) ClearLdapUsers() {
	m.clearedldap_users = true
}

// LdapUsersCleared reports if the "ldap_users" edge to the LDAPUser entity was cleared.
func (m *TeamMutation) LdapUsersCleared() bool {
	return m.clearedldap_users
}

// RemoveLdapUserIDs removes the "ldap_users" edge to the LDAPUser entity by IDs.
func (m *TeamMutation) RemoveLdapUserIDs(ids ...int) {
	if m.removedldap_users == nil {
		m.removedldap_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ldap_users, ids[i])
		m.removedldap_users[ids[i]] = struct{}{}
	}
}

// RemovedLdapUsers returns the removed IDs of the "ldap_users" edge to the LDAPUser entity.
func (m *TeamMutation) RemovedLdapUsersIDs() (ids []int) {
	for id := range m.removedldap_users {
		ids = append(ids, id)
	}
	return
}

// LdapUsersIDs returns the "ldap_users" edge IDs in the mutation.
func (m *TeamMutation) LdapUsersIDs() (ids []int) {
	for id := range m.ldap_users {
		ids = append(ids, id)
	}
	return
}

// ResetLdapUsers resets all changes to the "ldap_users" edge.
func (m *TeamMutation) ResetLdapUsers() {
	m.ldap_users = nil
	m.clearedldap_users = false
	m.removedldap_users = nil
}

// AddManagedUserIDs adds the "managed_users" edge to the ManagedUser entity by ids.
func (m *TeamMutation) AddManagedUserIDs(ids ...int) {
	if m.managed_users == nil {
		m.managed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.managed_users[ids[i]] = struct{}{}
	}
}

// ClearManagedUsers clears the "managed_users" edge to the ManagedUser entity.
func (m *TeamMutation) ClearManagedUsers() {
	m.clearedmanaged_users = true
}

// ManagedUsersCleared reports if the "managed_users" edge to the ManagedUser entity was cleared.
func (m *TeamMutation) ManagedUsersCleared() bool {
	return m.clearedmanaged_users
}

// RemoveManagedUserIDs removes the "managed_users" edge to the ManagedUser entity by IDs.
func (m *TeamMutation) RemoveManagedUserIDs(ids ...int) {
	if m.removedmanaged_users == nil {
		m.removedmanaged_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.managed_users, ids[i])
		m.removedmanaged_users[ids[i]] = struct{}{}
	}
}

// RemovedManagedUsers returns the removed IDs of the "managed_users" edge to the ManagedUser entity.
func (m *TeamMutation) RemovedManagedUsersIDs() (ids []int) {
	for id := range m.removedmanaged_users {
		ids = append(ids, id)
	}
	return
}

// ManagedUsersIDs returns the "managed_users" edge IDs in the mutation.
func (m *TeamMutation) ManagedUsersIDs() (ids []int) {
	for id := range m.managed_users {
		ids = append(ids, id)
	}
	return
}

// ResetManagedUsers resets all changes to the "managed_users" edge.
func (m *TeamMutation) ResetManagedUsers() {
	m.managed_users = nil
	m.clearedmanaged_users = false
	m.removedmanaged_users = nil
}

// AddOidcUserIDs adds the "oidc_users" edge to the OIDCUser entity by ids.
func (m *TeamMutation) AddOidcUserIDs(ids ...int) {
	if m.oidc_users == nil {
		m.oidc_users = make(map[int]struct{})
	}
	for i := range ids {
		m.oidc_users[ids[i]] = struct{}{}
	}
}

// ClearOidcUsers clears the "oidc_users" edge to the OIDCUser entity.
func (m *TeamMutation) ClearOidcUsers() {
	m.clearedoidc_users = true
}

// OidcUsersCleared reports if the "oidc_users" edge to the OIDCUser entity was cleared.
func (m *TeamMutation) OidcUsersCleared() bool {
	return m.clearedoidc_users
}

// RemoveOidcUserIDs removes the "oidc_users" edge to the OIDCUser entity by IDs.
func (m *TeamMutation) RemoveOidcUserIDs(ids ...int) {
	if m.removedoidc_users == nil {
		m.removedoidc_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.oidc_users, ids[i])
		m.removedoidc_users[ids[i]] = struct{}{}
	}
}

// RemovedOidcUsers returns the removed IDs of the "oidc_users" edge to the OIDCUser entity.
func (m *TeamMutation) RemovedOidcUsersIDs() (ids []int) {
	for id := range m.removedoidc_users {
		ids = append(ids, id)
	}
	return
}

// OidcUsersIDs returns the "oidc_users" edge IDs in the mutation.
func (m *TeamMutation) OidcUsersIDs() (ids []int) {
	for id := range m.oidc_users {
		ids = append(ids, id)
	}
	return
}

// ResetOidcUsers resets all changes to the "oidc_users" edge.
func (m *TeamMutation) ResetOidcUsers() {
	m.oidc_users = nil
	m.clearedoidc_users = false
	m.removedoidc_users = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.uuid != nil {
		fields = append(fields, team.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldUUID:
		return m.UUID()
	case team.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldUUID:
		return m.OldUUID(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldUUID:
		m.ResetUUID()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.api_keys != nil {
		edges = append(edges, team.EdgeAPIKeys)
	}
	if m.permissions != nil {
		edges = append(edges, team.EdgePermissions)
	}
	if m.oidc_groups != nil {
		edges = append(edges, team.EdgeOidcGroups)
	}
	if m.mapped_ldap_groups != nil {
		edges = append(edges, team.EdgeMappedLdapGroups)
	}
	if m.mapped_oidc_groups != nil {
		edges = append(edges, team.EdgeMappedOidcGroups)
	}
	if m.ldap_users != nil {
		edges = append(edges, team.EdgeLdapUsers)
	}
	if m.managed_users != nil {
		edges = append(edges, team.EdgeManagedUsers)
	}
	if m.oidc_users != nil {
		edges = append(edges, team.EdgeOidcUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOidcGroups:
		ids := make([]ent.Value, 0, len(m.oidc_groups))
		for id := range m.oidc_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMappedLdapGroups:
		ids := make([]ent.Value, 0, len(m.mapped_ldap_groups))
		for id := range m.mapped_ldap_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMappedOidcGroups:
		ids := make([]ent.Value, 0, len(m.mapped_oidc_groups))
		for id := range m.mapped_oidc_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeLdapUsers:
		ids := make([]ent.Value, 0, len(m.ldap_users))
		for id := range m.ldap_users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeManagedUsers:
		ids := make([]ent.Value, 0, len(m.managed_users))
		for id := range m.managed_users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOidcUsers:
		ids := make([]ent.Value, 0, len(m.oidc_users))
		for id := range m.oidc_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedapi_keys != nil {
		edges = append(edges, team.EdgeAPIKeys)
	}
	if m.removedpermissions != nil {
		edges = append(edges, team.EdgePermissions)
	}
	if m.removedoidc_groups != nil {
		edges = append(edges, team.EdgeOidcGroups)
	}
	if m.removedmapped_ldap_groups != nil {
		edges = append(edges, team.EdgeMappedLdapGroups)
	}
	if m.removedmapped_oidc_groups != nil {
		edges = append(edges, team.EdgeMappedOidcGroups)
	}
	if m.removedldap_users != nil {
		edges = append(edges, team.EdgeLdapUsers)
	}
	if m.removedmanaged_users != nil {
		edges = append(edges, team.EdgeManagedUsers)
	}
	if m.removedoidc_users != nil {
		edges = append(edges, team.EdgeOidcUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOidcGroups:
		ids := make([]ent.Value, 0, len(m.removedoidc_groups))
		for id := range m.removedoidc_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMappedLdapGroups:
		ids := make([]ent.Value, 0, len(m.removedmapped_ldap_groups))
		for id := range m.removedmapped_ldap_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMappedOidcGroups:
		ids := make([]ent.Value, 0, len(m.removedmapped_oidc_groups))
		for id := range m.removedmapped_oidc_groups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeLdapUsers:
		ids := make([]ent.Value, 0, len(m.removedldap_users))
		for id := range m.removedldap_users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeManagedUsers:
		ids := make([]ent.Value, 0, len(m.removedmanaged_users))
		for id := range m.removedmanaged_users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOidcUsers:
		ids := make([]ent.Value, 0, len(m.removedoidc_users))
		for id := range m.removedoidc_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedapi_keys {
		edges = append(edges, team.EdgeAPIKeys)
	}
	if m.clearedpermissions {
		edges = append(edges, team.EdgePermissions)
	}
	if m.clearedoidc_groups {
		edges = append(edges, team.EdgeOidcGroups)
	}
	if m.clearedmapped_ldap_groups {
		edges = append(edges, team.EdgeMappedLdapGroups)
	}
	if m.clearedmapped_oidc_groups {
		edges = append(edges, team.EdgeMappedOidcGroups)
	}
	if m.clearedldap_users {
		edges = append(edges, team.EdgeLdapUsers)
	}
	if m.clearedmanaged_users {
		edges = append(edges, team.EdgeManagedUsers)
	}
	if m.clearedoidc_users {
		edges = append(edges, team.EdgeOidcUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeAPIKeys:
		return m.clearedapi_keys
	case team.EdgePermissions:
		return m.clearedpermissions
	case team.EdgeOidcGroups:
		return m.clearedoidc_groups
	case team.EdgeMappedLdapGroups:
		return m.clearedmapped_ldap_groups
	case team.EdgeMappedOidcGroups:
		return m.clearedmapped_oidc_groups
	case team.EdgeLdapUsers:
		return m.clearedldap_users
	case team.EdgeManagedUsers:
		return m.clearedmanaged_users
	case team.EdgeOidcUsers:
		return m.clearedoidc_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case team.EdgePermissions:
		m.ResetPermissions()
		return nil
	case team.EdgeOidcGroups:
		m.ResetOidcGroups()
		return nil
	case team.EdgeMappedLdapGroups:
		m.ResetMappedLdapGroups()
		return nil
	case team.EdgeMappedOidcGroups:
		m.ResetMappedOidcGroups()
		return nil
	case team.EdgeLdapUsers:
		m.ResetLdapUsers()
		return nil
	case team.EdgeManagedUsers:
		m.ResetManagedUsers()
		return nil
	case team.EdgeOidcUsers:
		m.ResetOidcUsers()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}
